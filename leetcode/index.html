<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>力扣 | loommii</title>
<meta name="keywords" content="">
<meta name="description" content="力扣 - loommii">
<meta name="author" content="">
<link rel="canonical" href="https://loommii.github.io/leetcode/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://loommii.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://loommii.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://loommii.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://loommii.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://loommii.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://loommii.github.io/leetcode/index.xml">
<link rel="alternate" hreflang="zh" href="https://loommii.github.io/leetcode/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://loommii.github.io/leetcode/">
  <meta property="og:site_name" content="loommii">
  <meta property="og:title" content="力扣">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="力扣">
<meta name="twitter:description" content="">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://loommii.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "力扣",
      "item": "https://loommii.github.io/leetcode/"
    }
  ]
}
</script>


</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://loommii.github.io/" accesskey="h" title="loommii (Alt + H)">loommii</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://loommii.github.io/skill/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://loommii.github.io/go_practise/" title="Golang练习">
                    <span>Golang练习</span>
                </a>
            </li>
            <li>
                <a href="https://loommii.github.io/leetcode/" title="力扣">
                    <span class="active">力扣</span>
                </a>
            </li>
            <li>
                <a href="https://loommii.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://loommii.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://loommii.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://loommii.github.io/posts/">Posts</a></div>
  <h1>
    力扣
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">209_长度最小的子数组
    </h2>
  </header>
  <div class="entry-content">
    <p>力扣链接:209. 长度最小的子数组
力扣难度 中等
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [nums[l], nums[l&#43;1], ..., nums[r-1], nums[r]] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
示例 示例 1： 输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：&gt; 子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 输入：target = 4, nums = [1,4,4] 输出：1 示例 3： 输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示： 1 &lt;= target &lt;= 10^9 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^4 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 func minSubArrayLen(target int, nums []int) int { } func minSubArrayLen(target int, nums []int) int { n := len(nums) ans := n &#43; 1 s := 0 left := 0 // 左边下标 for right, num := range nums { // 右边下标 s &#43;= num for s-nums[left] &gt;= target { s -= nums[left] left&#43;&#43; } if s &gt;= target { ans = min(ans, right-left&#43;1) } } if ans == n&#43;1 { return 0 } return ans } func minSubArrayLen(target int, nums []int) int { n := len(nums) ans := n &#43; 1 s := 0 left := 0 // 左边下标 for right, num := range nums { // 右边下标 s &#43;= num for s &gt;= target { ans = min(ans, right-left&#43;1) s -= nums[left] left&#43;&#43; } } if ans == n&#43;1 { return 0 } return ans } </p>
  </div>
  <footer class="entry-footer"><span title='2025-05-05 20:19:46 +0800 CST'>五月 5, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 209_长度最小的子数组" href="https://loommii.github.io/posts/leetcode/data/209_%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">42_接雨水
    </h2>
  </header>
  <div class="entry-content">
    <p>力扣链接:42. 接雨水
力扣难度 困难
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
示例 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：&gt; 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 输入：height = [4,2,0,3,2,5] 输出：9 提示： n == height.length 1 &lt;= n &lt;= 2 * 10^4 0 &lt;= height[i] &lt;= 10^5 func trap(height []int) int { } func trap(height []int) int { ans := 0 n := len(height) prefixMaxNum := make([]int, n) suffixMaxNum := make([]int, n) prefixMaxNum[0] = height[0] for i := 1; i &lt; n; i&#43;&#43; { prefixMaxNum[i] = max(height[i], prefixMaxNum[i-1]) } suffixMaxNum[n-1] = height[n-1] for i := n - 2; i &gt;= 0; i-- { suffixMaxNum[i] = max(height[i], suffixMaxNum[i&#43;1]) } for i := 0; i &lt; n; i&#43;&#43; { ans &#43;= min(prefixMaxNum[i], suffixMaxNum[i]) - height[i] } return ans } func trap(height []int) int { ans := 0 n := len(height) left := 0 // 指向最左边 right := n - 1 // 指向最右边 pro_max := 0 // 前缀最大值 suf_max := 0 // 后缀最大值 for left &lt;= right { pro_max = max(pro_max, height[left]) suf_max = max(suf_max, height[right]) if pro_max &lt; suf_max { ans &#43;= pro_max - height[left] left&#43;&#43; } else { ans &#43;= suf_max - height[right] right-- } } return ans } </p>
  </div>
  <footer class="entry-footer"><span title='2025-05-05 17:11:10 +0800 CST'>五月 5, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 42_接雨水" href="https://loommii.github.io/posts/leetcode/data/42_%E6%8E%A5%E9%9B%A8%E6%B0%B4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">11_盛最多水的容器
    </h2>
  </header>
  <div class="entry-content">
    <p>力扣链接:11. 盛最多水的容器
力扣难度 中等
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
说明： 你不能倾斜容器。
示例 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：&gt; 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2： 输入：height = [1,1] 输出：1 提示： n == height.length 2 &lt;= n &lt;= 10^5 0 &lt;= height[i] &lt;= 10^4 func maxArea(height []int) int { } func maxArea(height []int) int { ans := 0 i := 0 // 左指针下标 j := len(height) - 1 // 右指针下标 // 循环 for i &lt; j { // 目前的面积 ans = max(ans, min(height[j], height[i])*(j-i)) // 最小的高 * 相距的宽 if height[i] &lt;= height[j] { i&#43;&#43; } else { j-- } } return ans } </p>
  </div>
  <footer class="entry-footer"><span title='2025-05-05 16:31:16 +0800 CST'>五月 5, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 11_盛最多水的容器" href="https://loommii.github.io/posts/leetcode/data/11_%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">15_三数之和
    </h2>
  </header>
  <div class="entry-content">
    <p>力扣链接:15. 三数之和
力扣难度 中等
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] &#43; nums[j] &#43; nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
注意： 答案中不可以包含重复的三元组。
示例 示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解释： nums[0] &#43; nums[1] &#43; nums[2] = (-1) &#43; 0 &#43; 1 = 0 。 nums[1] &#43; nums[2] &#43; nums[4] = 0 &#43; 1 &#43; (-1) = 0 。 nums[0] &#43; nums[3] &#43; nums[4] = (-1) &#43; 2 &#43; (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 示例 2： 输入：nums = [0,1,1] 输出：[] 解释：&gt; 唯一可能的三元组和不为 0 。 示例 3： 输入：nums = [0,0,0] 输出：[[0,0,0]] 解释：&gt; 唯一可能的三元组和为 0 。 提示： 3 &lt;= nums.length &lt;= 3000 -10^5 &lt;= nums[i] &lt;= 10^5 func threeSum(nums []int) [][]int { } func threeSum(nums []int) [][]int { ans := make([][]int, 0) // 数组排序 // 因为 输出的顺序和三元组的顺序并不重要，因此我们将原数组顺序打乱，按照从小到大排序方便后续处理 sort.Ints(nums) // 便利选择第一个数数 K 使得后面两边的数 J L 两个数加起来 等于 K的倒数 J &#43; L = - K n := len(nums) for i := 0; i &lt; len(nums)-2; i&#43;&#43; { // 后面至少还有2个数，因此需要遍历到len(nums)-2 if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] { // 重复要跳过 i == 0 时前面没有数 continue } j := i &#43; 1 l := n - 1 for j &lt; l { s := nums[i] &#43; nums[j] &#43; nums[l] if s &gt; 0 { l-- } else if s &lt; 0 { j&#43;&#43; } else { // 找到目标 ans = append(ans, []int{nums[i], nums[j], nums[l]}) // 避免重复 继续看一下相临的数是否重复，是的话都跳过 j&#43;&#43; for j &lt; l &amp;&amp; nums[j] == nums[j-1] { j&#43;&#43; } l-- for j &lt; l &amp;&amp; nums[l] == nums[l&#43;1] { l-- } } } } return ans } func threeSum(nums []int) [][]int { ans := make([][]int, 0) // 数组排序 // 因为 输出的顺序和三元组的顺序并不重要，因此我们将原数组顺序打乱，按照从小到大排序方便后续处理 sort.Ints(nums) // 便利选择第一个数数 K 使得后面两边的数 J L 两个数加起来 等于 K的倒数 J &#43; L = - K n := len(nums) for i := 0; i &lt; len(nums)-2; i&#43;&#43; { // 后面至少还有2个数，因此需要遍历到len(nums)-2 if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] { // 重复要跳过 i == 0 时前面没有数 continue } // 优化 一 最小的2个数和nums[i]加起来都&gt;0 这不用进入 if nums[i]&#43;nums[i&#43;1]&#43;nums[i&#43;2] &gt; 0 { continue } // 优化 一 最大的2个数和nums[i]加起来都&lt;0 这不用进入 if nums[i]&#43;nums[n-1]&#43;nums[n-2] &lt; 0 { continue } j := i &#43; 1 l := n - 1 for j &lt; l { s := nums[i] &#43; nums[j] &#43; nums[l] if s &gt; 0 { l-- } else if s &lt; 0 { j&#43;&#43; } else { // 找到目标 ans = append(ans, []int{nums[i], nums[j], nums[l]}) // 避免重复 继续看一下相临的数是否重复，是的话都跳过 j&#43;&#43; for j &lt; l &amp;&amp; nums[j] == nums[j-1] { j&#43;&#43; } l-- for j &lt; l &amp;&amp; nums[l] == nums[l&#43;1] { l-- } } } } return ans } </p>
  </div>
  <footer class="entry-footer"><span title='2025-05-05 15:38:02 +0800 CST'>五月 5, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 15_三数之和" href="https://loommii.github.io/posts/leetcode/data/15_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">167._两数之和_II_ _输入有序数组
    </h2>
  </header>
  <div class="entry-content">
    <p>力扣链接:167. 两数之和 II - 输入有序数组
力扣难度 中等
给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。
以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。
你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。
你所设计的解决方案必须只使用 常量级的额外空间。
示例 示例 1： 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：&gt; 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[1,3] 解释：&gt; 2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。 示例 3： 输入：numbers = [-1,0], target = -1 输出：[1,2] 解释：&gt; -1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。 提示： 2 &lt;= numbers.length &lt;= 3 * 104 -1000 &lt;= numbers[i] &lt;= 1000 numbers 按 非递减顺序 排列 -1000 &lt;= target &lt;= 1000 仅存在一个有效答案 func twoSum(numbers []int, target int) []int { } func twoSum(numbers []int, target int) (ans []int) { // 双指针 头指向最小 尾指向最大 // 头 &#43; 尾 &lt; 目标数 头指针就要往尾移动 // 头 &#43; 尾 &gt; 目标数 尾指针就要往头移动 // 头 &#43; 尾 = 目标数 返回答案 // 双指针 相遇 返回 nil j := 0 k := len(numbers) - 1 for j &lt; k { f := target - (numbers[j] &#43; numbers[k]) if f == 0 { return []int{j &#43; 1, k &#43; 1} } else if f &gt; 0 { j&#43;&#43; } else if f &lt; 0 { k-- } } return } </p>
  </div>
  <footer class="entry-footer"><span title='2025-05-01 17:40:06 +0800 CST'>五月 1, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 167._两数之和_II_ _输入有序数组" href="https://loommii.github.io/posts/leetcode/data/167._%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C_ii_-_%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">1295_统计位数为偶数的数字
    </h2>
  </header>
  <div class="entry-content">
    <p>力扣链接: 1295. 统计位数为偶数的数字
力扣难度 简单
给你一个整数数组 nums，请你返回其中包含 偶数 个数位的数字的个数。
示例 1： 输入：nums = [12,345,2,6,7896] 输出：2 解释：
12 是 2 位数字（位数为偶数） 345 是 3 位数字（位数为奇数） 2 是 1 位数字（位数为奇数） 6 是 1 位数字（位数为奇数） 7896 是 4 位数字（位数为偶数） 因此只有 12 和 7896 是位数为偶数的数字。
示例 2： 输入：nums = [555,901,482,1771] 输出：1 解释： 只有 1771 是位数为偶数的数字。
提示： 1 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 105 func findNumbers(nums []int) int { } func findNumbers(nums []int) int { // 计数 ans := 0 for _, v := range nums { i := 0 for v != 0 { i&#43;&#43; v /= 10 } if i%2 == 0 { ans&#43;&#43; } } return ans } </p>
  </div>
  <footer class="entry-footer"><span title='2025-04-30 17:24:19 +0800 CST'>四月 30, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 1295_统计位数为偶数的数字" href="https://loommii.github.io/posts/leetcode/data/1295_%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">160_相交链表
    </h2>
  </header>
  <div class="entry-content">
    <p>160. 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。
图示两个链表在节点 c1 开始相交**：**
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
自定义评测：
评测系统 的输入如下（你设计的程序 不适用 此输入）：
intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
listA - 第一个链表
listB - 第二个链表
skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数
评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。
示例 1：
**输入：**intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 **输出：**Intersected at &#39;8&#39; **解释：**相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 — 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。 示例 2：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-03-02 19:15:44 +0800 CST'>三月 2, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 160_相交链表" href="https://loommii.github.io/posts/leetcode/data/160_%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">1287_有序数组中出现次数超过25%的元素
    </h2>
  </header>
  <div class="entry-content">
    <p>力扣链接: 1287. 有序数组中出现次数超过25%的元素
力扣难度 简单
算法评级: 3 理解常用数据结构和算法
难度分 1179
题目: 给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。
请你找到并返回这个整数
示例：
输入：arr = [1,2,2,6,6,6,6,7,10]
输出：6
提示：
1 &lt;= arr.length &lt;= 10^4 0 &lt;= arr[i] &lt;= 10^5 func findSpecialInteger(arr []int) int { } 👈点击 func findSpecialInteger(arr []int) (ans int) { n := len(arr) / 4 f := arr[0] i := 0 for _, v := range arr { if v == f { i&#43;&#43; } else { f = v i = 1 } if i &gt; n { ans = f break } } return } </p>
  </div>
  <footer class="entry-footer"><span title='2025-02-17 17:56:19 +0800 CST'>二月 17, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 1287_有序数组中出现次数超过25%的元素" href="https://loommii.github.io/posts/leetcode/data/1287_%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%8725%E7%9A%84%E5%85%83%E7%B4%A0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">1299_将每个元素替换为右侧最大元素
    </h2>
  </header>
  <div class="entry-content">
    <p>力扣链接: 1299. 将每个元素替换为右侧最大元素
力扣难度 简单
算法评级: 3 理解常用数据结构和算法
难度分 1219
题目: 给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。
完成所有替换操作后，请你返回这个数组。
示例 1：
输入：arr = [17,18,5,4,6,1] 输出：[18,6,6,6,1,-1] 解释：
下标 0 的元素 –&gt; 右侧最大元素是下标 1 的元素 (18) 下标 1 的元素 –&gt; 右侧最大元素是下标 4 的元素 (6) 下标 2 的元素 –&gt; 右侧最大元素是下标 4 的元素 (6) 下标 3 的元素 –&gt; 右侧最大元素是下标 4 的元素 (6) 下标 4 的元素 –&gt; 右侧最大元素是下标 5 的元素 (1) 下标 5 的元素 –&gt; 右侧没有其他元素，替换为 -1 示例 2：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-02-16 23:49:25 +0800 CST'>二月 16, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 1299_将每个元素替换为右侧最大元素" href="https://loommii.github.io/posts/leetcode/data/1299_%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">2264_字符串中最大的3位相同数字
    </h2>
  </header>
  <div class="entry-content">
    <p>力扣链接:2264. 字符串中最大的 3 位相同数字
力扣难度 简单
算法评级: 2
难度分 1309
题目：
给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ：
该整数是 num 的一个长度为 3 的 子字符串 。 该整数由唯一一个数字重复 3 次组成。 以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 &#34;&#34; 。
注意：
子字符串 是字符串中的一个连续字符序列。 num 或优质整数中可能存在 前导零 。 示例 1：
输入：num = “6777133339”
输出：“777”
解释：num 中存在两个优质整数：“777” 和 “333” 。
“777” 是最大的那个，所以返回 “777” 。
示例 2：
输入：num = “2300019”
输出：“000”
解释：“000” 是唯一一个优质整数。
示例 3：
输入：num = “42352338”
输出：&#34;&#34;
解释：不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-01-08 14:00:23 +0800 CST'>一月 8, 2025</span></footer>
  <a class="entry-link" aria-label="post link to 2264_字符串中最大的3位相同数字" href="https://loommii.github.io/posts/leetcode/data/2264_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%843%E4%BD%8D%E7%9B%B8%E5%90%8C%E6%95%B0%E5%AD%97/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://loommii.github.io/leetcode/page/2/">下一页&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://loommii.github.io/">loommii</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
