<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>力扣 on loommii</title>
    <link>https://loommii.github.io/leetcode/</link>
    <description>Recent content in 力扣 on loommii</description>
    <generator>Hugo -- 0.143.1</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 17 Feb 2025 17:56:19 +0800</lastBuildDate>
    <atom:link href="https://loommii.github.io/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1287_有序数组中出现次数超过25%的元素</title>
      <link>https://loommii.github.io/posts/leetcode/data/1287_%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%8725%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Mon, 17 Feb 2025 17:56:19 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/1287_%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%8725%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>&lt;p&gt;力扣链接: &lt;a href=&#34;https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/description/&#34;&gt;1287. 有序数组中出现次数超过25%的元素&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级:  3      理解常用数据结构和算法&lt;/p&gt;
&lt;p&gt;难度分 1179&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目:&lt;br&gt;
给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。&lt;/p&gt;
&lt;p&gt;请你找到并返回这个整数&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：arr = [1,2,2,6,6,6,6,7,10]&lt;br&gt;
输出：6&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= arr.length &amp;lt;= 10^4&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= arr[i] &amp;lt;= 10^5&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;findSpecialInteger&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;button class=&#34;toggle-button&#34; onclick=&#34;this.nextElementSibling.classList.toggle(&#39;show&#39;)&#34;&gt;👈点击&lt;/button&gt;
&lt;div class=&#34;toggle-content&#34;&gt;
  &lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;findSpecialInteger&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;ans&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#a6e22e&#34;&gt;ans&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
  .toggle-content {
    display: none;
    margin-top: 10px;
  }
  .toggle-content.show {
    display: block;
  }
&lt;/style&gt;</description>
    </item>
    <item>
      <title>1299_将每个元素替换为右侧最大元素</title>
      <link>https://loommii.github.io/posts/leetcode/data/1299_%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 16 Feb 2025 23:49:25 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/1299_%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>&lt;p&gt;力扣链接: &lt;a href=&#34;https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/description/&#34;&gt;1299. 将每个元素替换为右侧最大元素&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级:  3      理解常用数据结构和算法&lt;/p&gt;
&lt;p&gt;难度分 1219&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目:&lt;br&gt;
给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。&lt;/p&gt;
&lt;p&gt;完成所有替换操作后，请你返回这个数组。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：arr = [17,18,5,4,6,1]
输出：[18,6,6,6,1,-1]
解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下标 0 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 1 的元素 (18)&lt;/li&gt;
&lt;li&gt;下标 1 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 4 的元素 (6)&lt;/li&gt;
&lt;li&gt;下标 2 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 4 的元素 (6)&lt;/li&gt;
&lt;li&gt;下标 3 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 4 的元素 (6)&lt;/li&gt;
&lt;li&gt;下标 4 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 5 的元素 (1)&lt;/li&gt;
&lt;li&gt;下标 5 的元素 &amp;ndash;&amp;gt; 右侧没有其他元素，替换为 -1&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;</description>
    </item>
    <item>
      <title>2264_字符串中最大的3位相同数字</title>
      <link>https://loommii.github.io/posts/leetcode/data/2264_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%843%E4%BD%8D%E7%9B%B8%E5%90%8C%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 08 Jan 2025 14:00:23 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/2264_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%843%E4%BD%8D%E7%9B%B8%E5%90%8C%E6%95%B0%E5%AD%97/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/largest-3-same-digit-number-in-string/description/&#34;&gt;2264. 字符串中最大的 3 位相同数字&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;&lt;br&gt;
算法评级: 2&lt;br&gt;
难度分 1309&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该整数是 num 的一个长度为 3 的 子字符串 。&lt;/li&gt;
&lt;li&gt;该整数由唯一一个数字重复 3 次组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 &amp;quot;&amp;quot; 。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子字符串 是字符串中的一个连续字符序列。&lt;/li&gt;
&lt;li&gt;num 或优质整数中可能存在 前导零 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：num = &amp;ldquo;6777133339&amp;rdquo;&lt;br&gt;
输出：&amp;ldquo;777&amp;rdquo;&lt;br&gt;
解释：num 中存在两个优质整数：&amp;ldquo;777&amp;rdquo; 和 &amp;ldquo;333&amp;rdquo; 。&lt;br&gt;
&amp;ldquo;777&amp;rdquo; 是最大的那个，所以返回 &amp;ldquo;777&amp;rdquo; 。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：num = &amp;ldquo;2300019&amp;rdquo;&lt;br&gt;
输出：&amp;ldquo;000&amp;rdquo;&lt;br&gt;
解释：&amp;ldquo;000&amp;rdquo; 是唯一一个优质整数。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：num = &amp;ldquo;42352338&amp;rdquo;&lt;br&gt;
输出：&amp;quot;&amp;quot;&lt;br&gt;
解释：不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。&lt;/p&gt;</description>
    </item>
    <item>
      <title>3019_按键变更的次数</title>
      <link>https://loommii.github.io/posts/leetcode/data/3019_%E6%8C%89%E9%94%AE%E5%8F%98%E6%9B%B4%E7%9A%84%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Tue, 07 Jan 2025 21:47:21 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/3019_%E6%8C%89%E9%94%AE%E5%8F%98%E6%9B%B4%E7%9A%84%E6%AC%A1%E6%95%B0/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/number-of-changing-keys/description/&#34;&gt;3019. 按键变更的次数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;
算法评级: 2      知道常用数据结构和算法并简单使用
难度分 1176&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目:&lt;/p&gt;
&lt;p&gt;给你一个下标从 0 开始的字符串 s ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 s = &amp;ldquo;ab&amp;rdquo; 表示按键变更一次，而 s = &amp;ldquo;bBBb&amp;rdquo; 不存在按键变更。&lt;/p&gt;
&lt;p&gt;返回用户输入过程中按键变更的次数。&lt;/p&gt;
&lt;p&gt;注意：shift 或 caps lock 等修饰键不计入按键变更，也就是说，如果用户先输入字母 &amp;lsquo;a&amp;rsquo; 然后输入字母 &amp;lsquo;A&amp;rsquo; ，不算作按键变更。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：s = &amp;ldquo;aAbBcC&amp;rdquo;&lt;br&gt;
输出：2&lt;br&gt;
解释：&lt;br&gt;
从 s[0] = &amp;lsquo;a&amp;rsquo; 到 s[1] = &amp;lsquo;A&amp;rsquo;，不存在按键变更，因为不计入 caps lock 或 shift 。&lt;br&gt;
从 s[1] = &amp;lsquo;A&amp;rsquo; 到 s[2] = &amp;lsquo;b&amp;rsquo;，按键变更。&lt;br&gt;
从 s[2] = &amp;lsquo;b&amp;rsquo; 到 s[3] = &amp;lsquo;B&amp;rsquo;，不存在按键变更，因为不计入 caps lock 或 shift 。&lt;br&gt;
从 s[3] = &amp;lsquo;B&amp;rsquo; 到 s[4] = &amp;lsquo;c&amp;rsquo;，按键变更。&lt;br&gt;
从 s[4] = &amp;lsquo;c&amp;rsquo; 到 s[5] = &amp;lsquo;C&amp;rsquo;，不存在按键变更，因为不计入 caps lock 或 shift 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>3083_字符串及其反转中是否存在同一子字符串</title>
      <link>https://loommii.github.io/posts/leetcode/data/3083_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E5%8F%8D%E8%BD%AC%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%90%8C%E4%B8%80%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 28 Dec 2024 18:04:37 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/3083_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E5%8F%8D%E8%BD%AC%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%90%8C%E4%B8%80%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/existence-of-a-substring-in-a-string-and-its-reverse/description/&#34;&gt;3083. 字符串及其反转中是否存在同一子字符串&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;&lt;br&gt;
算法评级:  2      知道常用数据结构和算法并简单使用&lt;br&gt;
难度分 1173&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;给你一个字符串 s ，请你判断字符串 s 是否存在一个长度为 2 的子字符串，在其反转后的字符串中也出现。&lt;/p&gt;
&lt;p&gt;如果存在这样的子字符串，返回 true；如果不存在，返回 false 。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：s = &amp;ldquo;leetcode&amp;rdquo;&lt;/p&gt;
&lt;p&gt;输出：true&lt;/p&gt;
&lt;p&gt;解释：子字符串 &amp;ldquo;ee&amp;rdquo; 的长度为 2，它也出现在 reverse(s) == &amp;ldquo;edocteel&amp;rdquo; 中。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：s = &amp;ldquo;abcba&amp;rdquo;&lt;/p&gt;
&lt;p&gt;输出：true&lt;/p&gt;
&lt;p&gt;解释：所有长度为 2 的子字符串 &amp;ldquo;ab&amp;rdquo;、&amp;ldquo;bc&amp;rdquo;、&amp;ldquo;cb&amp;rdquo;、&amp;ldquo;ba&amp;rdquo; 也都出现在 reverse(s) == &amp;ldquo;abcba&amp;rdquo; 中。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：s = &amp;ldquo;abcd&amp;rdquo;&lt;/p&gt;
&lt;p&gt;输出：false&lt;/p&gt;
&lt;p&gt;解释：字符串 s 中不存在满足「在其反转后的字符串中也出现」且长度为 2 的子字符串。&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isSubstringPresent&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;button class=&#34;toggle-button&#34; onclick=&#34;this.nextElementSibling.classList.toggle(&#39;show&#39;)&#34;&gt;🔑 答案解析： 👈点击&lt;/button&gt;
&lt;div class=&#34;toggle-content&#34;&gt;
  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// isSubstringPresent 函数用于判断给定字符串 s 中是否存在一对字符的子串，&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 这对字符以相反的顺序也出现过。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isSubstringPresent&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 创建一个 26×26 的布尔数组 vis，用于记录每对字符是否出现过。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 索引的含义是：vis[x][y] 表示字符 x 和字符 y 组成的子串是否出现过。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这里的 x 和 y 是字符在字母表中的索引，从 0 到 25 分别对应 &amp;#39;a&amp;#39; 到 &amp;#39;z&amp;#39;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;vis&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;26&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;{} 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历字符串 s，从第二个字符开始，因为要检查相邻的两个字符组成的子串。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;); &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 计算当前字符对中第一个字符在字母表中的索引。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 例如，如果字符是 &amp;#39;a&amp;#39;，则 x 为 0；如果是 &amp;#39;b&amp;#39;，则 x 为 1，以此类推。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 计算当前字符对中第二个字符在字母表中的索引。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 将当前字符对标记为已出现过。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;vis&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;][&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;] = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 检查是否存在相反顺序的字符对。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果 vis[y][x] 为 true，说明字符 y 和字符 x 组成的子串也出现过，&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 即找到了满足条件的子串，返回 true。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vis&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;][&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;] { 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 如果遍历完整个字符串都没有找到满足条件的子串，返回 false。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
  .toggle-content {
    display: none;
    margin-top: 10px;
  }
  .toggle-content.show {
    display: block;
  }
&lt;/style&gt;</description>
    </item>
    <item>
      <title>3159_查询数组中元素的出现位置</title>
      <link>https://loommii.github.io/posts/leetcode/data/3159_%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Sat, 28 Dec 2024 14:28:22 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/3159_%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/find-occurrences-of-an-element-in-an-array/description/&#34;&gt;3159. 查询数组中元素的出现位置&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;中等&lt;/code&gt;&lt;br&gt;
算法评级:  2      知道常用数据结构和算法并简单使用&lt;br&gt;
难度分 1263&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目：
给你一个整数数组 nums ，一个整数数组 queries 和一个整数 x 。&lt;/p&gt;
&lt;p&gt;对于每个查询 queries[i] ，你需要找到 nums 中第 queries[i] 个 x 的位置，并返回它的下标。如果数组中 x 的出现次数少于 queries[i] ，该查询的答案为 -1 。&lt;/p&gt;
&lt;p&gt;请你返回一个整数数组 answer ，包含所有查询的答案。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [1,3,1,7], queries = [1,3,2,4], x = 1&lt;/p&gt;
&lt;p&gt;输出：[0,-1,2,-1]&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 1 个查询，第一个 1 出现在下标 0 处。&lt;/li&gt;
&lt;li&gt;第 2 个查询，nums 中只有两个 1 ，所以答案为 -1 。&lt;/li&gt;
&lt;li&gt;第 3 个查询，第二个 1 出现在下标 2 处。&lt;/li&gt;
&lt;li&gt;第 4 个查询，nums 中只有两个 1 ，所以答案为 -1 。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;</description>
    </item>
    <item>
      <title>3046_分割数组</title>
      <link>https://loommii.github.io/posts/leetcode/data/3046_%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 28 Dec 2024 13:02:42 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/3046_%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/split-the-array/description/&#34;&gt;3046. 分割数组&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;&lt;br&gt;
算法评级:  2      知道常用数据结构和算法并简单使用&lt;br&gt;
难度分 1212&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目：
给你一个长度为 偶数 的整数数组 nums 。你需要将这个数组分割成 nums1 和 nums2 两部分，要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nums1.length == nums2.length == nums.length / 2 。&lt;/li&gt;
&lt;li&gt;nums1 应包含 互不相同 的元素。&lt;/li&gt;
&lt;li&gt;nums2也应包含 互不相同 的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果能够分割数组就返回 true ，否则返回 false 。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [1,1,2,2,3,4]&lt;br&gt;
输出：true&lt;br&gt;
解释：分割 nums 的可行方案之一是 nums1 = [1,2,3] 和 nums2 = [1,2,4] 。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [1,1,1,1]&lt;br&gt;
输出：false&lt;br&gt;
解释：分割 nums 的唯一可行方案是 nums1 = [1,1] 和 nums2 = [1,1] 。但 nums1 和 nums2 都不是由互不相同的元素构成。因此，返回 false 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>3285_找到稳定山的下标</title>
      <link>https://loommii.github.io/posts/leetcode/data/3285_%E6%89%BE%E5%88%B0%E7%A8%B3%E5%AE%9A%E5%B1%B1%E7%9A%84%E4%B8%8B%E6%A0%87/</link>
      <pubDate>Wed, 25 Dec 2024 15:05:58 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/3285_%E6%89%BE%E5%88%B0%E7%A8%B3%E5%AE%9A%E5%B1%B1%E7%9A%84%E4%B8%8B%E6%A0%87/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/find-indices-of-stable-mountains/description/&#34;&gt;3285. 找到稳定山的下标&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级:  1      无算法要求&lt;/p&gt;
&lt;p&gt;难度分 1166&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;有 n 座山排成一列，每座山都有一个高度。给你一个整数数组 height ，其中 height[i] 表示第 i 座山的高度，再给你一个整数 threshold 。&lt;/p&gt;
&lt;p&gt;对于下标不为 0 的一座山，如果它左侧相邻的山的高度 严格大于 threshold ，那么我们称它是 稳定 的。我们定义下标为 0 的山 不是 稳定的。&lt;/p&gt;
&lt;p&gt;请你返回一个数组，包含所有 稳定 山的下标，你可以以 任意 顺序返回下标数组。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：height = [1,2,3,4,5], threshold = 2&lt;/p&gt;
&lt;p&gt;输出：[3,4]&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;下标为 3 的山是稳定的，因为 height[2] == 3 大于 threshold == 2 。
下标为 4 的山是稳定的，因为 height[3] == 4 大于 threshold == 2.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;</description>
    </item>
    <item>
      <title>1387_将整数按权重排序</title>
      <link>https://loommii.github.io/posts/leetcode/data/1387_%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 22 Dec 2024 15:09:23 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/1387_%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/sort-integers-by-the-power-value/description/?envType=daily-question&amp;amp;envId=2024-12-22&#34;&gt;1387. 将整数按权重排序&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;中等&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级:  6      深入理解并灵活应用数据结构和算法，理解高级数据结构&lt;/p&gt;
&lt;p&gt;难度分 1507&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 x 是偶数，那么 x = x / 2&lt;/li&gt;
&lt;li&gt;如果 x 是奇数，那么 x = 3 * x + 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 &amp;ndash;&amp;gt; 10 &amp;ndash;&amp;gt; 5 &amp;ndash;&amp;gt; 16 &amp;ndash;&amp;gt; 8 &amp;ndash;&amp;gt; 4 &amp;ndash;&amp;gt; 2 &amp;ndash;&amp;gt; 1）。&lt;/p&gt;
&lt;p&gt;给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>2545_根据第K场考试的分数排序</title>
      <link>https://loommii.github.io/posts/leetcode/data/2545_%E6%A0%B9%E6%8D%AE%E7%AC%ACk%E5%9C%BA%E8%80%83%E8%AF%95%E7%9A%84%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 21 Dec 2024 13:47:52 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/2545_%E6%A0%B9%E6%8D%AE%E7%AC%ACk%E5%9C%BA%E8%80%83%E8%AF%95%E7%9A%84%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/sort-the-students-by-their-kth-score/description/?envType=daily-question&amp;amp;envId=2024-12-21&#34;&gt;2545. 根据第 K 场考试的分数排序&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;中等&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级:  3      理解常用数据结构和算法&lt;/p&gt;
&lt;p&gt;难度分 1294&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;班里有 m 位学生，共计划组织 n 场考试。给你一个下标从 0 开始、大小为 m x n 的整数矩阵 score ，其中每一行对应一位学生，而 score[i][j] 表示第 i 位学生在第 j 场考试取得的分数。矩阵 score 包含的整数 互不相同 。&lt;/p&gt;
&lt;p&gt;另给你一个整数 k 。请你按第 k 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。&lt;/p&gt;
&lt;p&gt;返回排序后的矩阵。&lt;/p&gt;
&lt;p&gt;示例 1：
&lt;img alt=&#34;alt text&#34; loading=&#34;lazy&#34; src=&#34;https://loommii.github.io/posts/leetcode/data/2545_%E6%A0%B9%E6%8D%AE%E7%AC%ACk%E5%9C%BA%E8%80%83%E8%AF%95%E7%9A%84%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F/image.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2 &lt;br&gt;
输出：[[7,5,11,2],[10,6,9,1],[4,8,3,15]]&lt;br&gt;
解释：在上图中，S 表示学生，E 表示考试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下标为 1 的学生在第 2 场考试取得的分数为 11 ，这是考试的最高分，所以 TA 需要排在第一。&lt;/li&gt;
&lt;li&gt;下标为 0 的学生在第 2 场考试取得的分数为 9 ，这是考试的第二高分，所以 TA 需要排在第二。&lt;/li&gt;
&lt;li&gt;下标为 2 的学生在第 2 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第三。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：
&lt;img alt=&#34;alt text&#34; loading=&#34;lazy&#34; src=&#34;https://loommii.github.io/posts/leetcode/data/2545_%E6%A0%B9%E6%8D%AE%E7%AC%ACk%E5%9C%BA%E8%80%83%E8%AF%95%E7%9A%84%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F/image-1.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>3138_同位字符串连接的最小长度</title>
      <link>https://loommii.github.io/posts/leetcode/data/3138_%E5%90%8C%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Fri, 20 Dec 2024 23:57:43 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/3138_%E5%90%8C%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/minimum-length-of-anagram-concatenation/description/?envType=daily-question&amp;amp;envId=2024-12-20&#34;&gt;3138. 同位字符串连接的最小长度&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;中等&lt;/code&gt;&lt;br&gt;
算法评级: 5      熟练掌握常用数据结构和算法，初步了解高级数据结构
难度分 1979&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目:&lt;br&gt;
给你一个字符串 s ，它由某个字符串 t 和若干 t  的 同位字符串 连接而成。&lt;/p&gt;
&lt;p&gt;请你返回字符串 t 的 最小 可能长度。&lt;/p&gt;
&lt;p&gt;同位字符串 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：s = &amp;ldquo;abba&amp;rdquo;&lt;/p&gt;
&lt;p&gt;输出：2&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;一个可能的字符串 t 为 &amp;ldquo;ba&amp;rdquo; 。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：s = &amp;ldquo;cdef&amp;rdquo;&lt;/p&gt;
&lt;p&gt;输出：4&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;一个可能的字符串 t 为 &amp;ldquo;cdef&amp;rdquo; ，注意 t 可能等于 s 。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= s.length &amp;lt;= 105&lt;/li&gt;
&lt;li&gt;s 只包含小写英文字母。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minAnagramLength&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;button class=&#34;toggle-button&#34; onclick=&#34;this.nextElementSibling.classList.toggle(&#39;show&#39;)&#34;&gt;🧠思路:  👈点击&lt;/button&gt;
&lt;div class=&#34;toggle-content&#34;&gt;
  &lt;h1 id=&#34;枚举&#34;&gt;枚举&lt;/h1&gt;
&lt;p&gt;设 s字符串的长度为n,阅读题目可得提供的s一定是由 字符串 t构成的。(有确定的结)&lt;/p&gt;</description>
    </item>
    <item>
      <title>3291_形成目标字符串需要的最少字符串数_I</title>
      <link>https://loommii.github.io/posts/leetcode/data/3291_%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0_i/</link>
      <pubDate>Tue, 17 Dec 2024 14:34:51 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/3291_%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0_i/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-i/description/?envType=daily-question&amp;amp;envId=2024-12-17&#34;&gt;3291. 形成目标字符串需要的最少字符串数 I&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;中等&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级:  6      深入理解并灵活应用数据结构和算法，理解高级数据结构&lt;/p&gt;
&lt;p&gt;难度分 2082&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目:
给你一个字符串数组 words 和一个字符串 target。&lt;/p&gt;
&lt;p&gt;如果字符串 x 是 words 中 任意 字符串的
前缀
，则认为 x 是一个 有效 字符串。&lt;/p&gt;
&lt;p&gt;现计划通过 连接 有效字符串形成 target ，请你计算并返回需要连接的 最少 字符串数量。如果无法通过这种方式形成 target，则返回 -1。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入： words = [&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;aaaaa&amp;rdquo;,&amp;ldquo;bcdef&amp;rdquo;], target = &amp;ldquo;aabcdabc&amp;rdquo;&lt;/p&gt;
&lt;p&gt;输出： 3&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;target 字符串可以通过连接以下有效字符串形成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;words[1] 的长度为 2 的前缀，即 &amp;ldquo;aa&amp;rdquo;。&lt;/li&gt;
&lt;li&gt;words[2] 的长度为 3 的前缀，即 &amp;ldquo;bcd&amp;rdquo;。&lt;/li&gt;
&lt;li&gt;words[0] 的长度为 3 的前缀，即 &amp;ldquo;abc&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入： words = [&amp;ldquo;abababab&amp;rdquo;,&amp;ldquo;ab&amp;rdquo;], target = &amp;ldquo;ababaababa&amp;rdquo;&lt;/p&gt;</description>
    </item>
    <item>
      <title>1847_最近的房间</title>
      <link>https://loommii.github.io/posts/leetcode/data/1847_%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%BF%E9%97%B4/</link>
      <pubDate>Mon, 16 Dec 2024 14:28:52 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/1847_%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%BF%E9%97%B4/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/closest-room/description/?envType=daily-question&amp;amp;envId=2024-12-16&#34;&gt;1847. 最近的房间&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;力扣难度 &lt;code&gt;困难&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级: 8      掌握不同的数据结构与算法之间的关联性，处理复杂问题，掌握高级数据结构&lt;/p&gt;
&lt;p&gt;难度分 2082&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;p&gt;一个酒店里有 n 个房间，这些房间用二维整数数组 rooms 表示，其中 rooms[i] = [roomIdi, sizei] 表示有一个房间号为 roomIdi 的房间且它的面积为 sizei 。每一个房间号 roomIdi 保证是 独一无二 的。&lt;/p&gt;
&lt;p&gt;同时给你 k 个查询，用二维数组 queries 表示，其中 queries[j] = [preferredj, minSizej] 。第 j 个查询的答案是满足如下条件的房间 id ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;房间的面积 至少 为 minSizej ，且abs(id - preferredj) 的值 最小 ，其中 abs(x) 是 x 的绝对值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。&lt;/p&gt;
&lt;p&gt;请你返回长度为 k 的数组 answer ，其中 answer[j] 为第 j 个查询的结果。&lt;/p&gt;</description>
    </item>
    <item>
      <title>1338_数组大小减半</title>
      <link>https://loommii.github.io/posts/leetcode/data/1338_%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A/</link>
      <pubDate>Sun, 15 Dec 2024 15:36:23 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/1338_%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/reduce-array-size-to-the-half/description/?envType=daily-question&amp;amp;envId=2024-12-15&#34;&gt;1338. 数组大小减半&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;力扣难度 &lt;code&gt;中等&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级: 3      理解常用数据结构和算法&lt;/p&gt;
&lt;p&gt;难度分 1303&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目:
给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。&lt;/p&gt;
&lt;p&gt;返回 至少 能删除数组中的一半整数的整数集合的最小大小&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：arr = [3,3,3,3,5,5,5,2,2,7]
输出：2
解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。
大小为 2 的可行集合有 {3,5},{3,2},{5,2}。
选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：arr = [7,7,7,7,7,7]
输出：1
解释：我们只能选择集合 {7}，结果数组为空。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= arr.length &amp;lt;= 105&lt;/li&gt;
&lt;li&gt;arr.length 为偶数&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= arr[i] &amp;lt;= 105&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minSetSize&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;button class=&#34;toggle-button&#34; onclick=&#34;this.nextElementSibling.classList.toggle(&#39;show&#39;)&#34;&gt;🧠思路:  👈点击&lt;/button&gt;
&lt;div class=&#34;toggle-content&#34;&gt;
  &lt;h3 id=&#34;猜想&#34;&gt;猜想&lt;/h3&gt;
&lt;p&gt;贪心的想法，先遍历一遍记录出现次数。从频率最高的开始删除
问题就变为了怎么记录次数后从大到小排序方便&lt;/p&gt;
&lt;/div&gt;
&lt;style&gt;
  .toggle-content {
    display: none;
    margin-top: 10px;
  }
  .toggle-content.show {
    display: block;
  }
&lt;/style&gt;

&lt;hr&gt;
&lt;button class=&#34;toggle-button&#34; onclick=&#34;this.nextElementSibling.classList.toggle(&#39;show&#39;)&#34;&gt;🔑 答案解析： 👈点击&lt;/button&gt;
&lt;div class=&#34;toggle-content&#34;&gt;
  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pair&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; } &lt;span style=&#34;color:#75715e&#34;&gt;// 值 和 次数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;pair&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Len&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;) }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Less&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 如果h[i]&amp;lt;h[j]生成的就是小根堆，如果h[i]&amp;gt;h[j]生成的就是大根堆&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 大顶堆&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Swap&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) { &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;], &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;] = &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;], &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Push&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;any&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; = append(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;.(&lt;span style=&#34;color:#a6e22e&#34;&gt;pair&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Pop&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;any&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;old&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;old&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;old&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;old&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; : &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minSetSize&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;CountMap&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;CountMap&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt; = make(&lt;span style=&#34;color:#a6e22e&#34;&gt;hp&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len(&lt;span style=&#34;color:#a6e22e&#34;&gt;CountMap&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CountMap&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;pair&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Init&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 堆初始化&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;ans&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pop&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;).(&lt;span style=&#34;color:#a6e22e&#34;&gt;pair&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;ans&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ans&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
  .toggle-content {
    display: none;
    margin-top: 10px;
  }
  .toggle-content.show {
    display: block;
  }
&lt;/style&gt;</description>
    </item>
    <item>
      <title>3266_K_次乘运算后的最终数组_II</title>
      <link>https://loommii.github.io/posts/leetcode/data/3266_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_ii/</link>
      <pubDate>Sat, 14 Dec 2024 12:13:03 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/3266_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_ii/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-i/description/?envType=daily-question&amp;amp;envId=2024-12-13&#34;&gt;3264. K 次乘运算后的最终数组 I&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;力扣难度 &lt;code&gt;困难&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级:  8      掌握不同的数据结构与算法之间的关联性，处理复杂问题，掌握高级数据结构&lt;/p&gt;
&lt;p&gt;难度分 2509&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目:
给你一个整数数组 nums ，一个整数 k  和一个整数 multiplier 。&lt;/p&gt;
&lt;p&gt;你需要对 nums 执行 k 次操作，每次操作中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到 nums 中的 最小 值 x ，如果存在多个最小值，选择最 前面 的一个&lt;/li&gt;
&lt;li&gt;将 x 替换为 x * multiplier 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;k 次操作以后，你需要将 nums 中每一个数值对 109 + 7 取余。
请你返回执行完 k 次乘运算以及取余运算之后，最终的 nums 数组。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [2,1,3,5,6], k = 5, multiplier = 2&lt;/p&gt;
&lt;p&gt;输出：[8,4,6,5,6]&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;操作&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;结果&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[2, 2, 3, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[4, 2, 3, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;3 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[4, 4, 3, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;4 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[4, 4, 6, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;5 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[8, 4, 6, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;</description>
    </item>
    <item>
      <title>3264_K_次乘运算后的最终数组_I</title>
      <link>https://loommii.github.io/posts/leetcode/data/3264_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_i/</link>
      <pubDate>Fri, 13 Dec 2024 15:58:17 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/3264_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_i/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-i/description/?envType=daily-question&amp;amp;envId=2024-12-13&#34;&gt;3264. K 次乘运算后的最终数组 I&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;算法评级: 3      理解常用数据结构和算法&lt;/p&gt;
&lt;p&gt;难度分 1178&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目:
给你一个整数数组 nums ，一个整数 k  和一个整数 multiplier 。&lt;/p&gt;
&lt;p&gt;你需要对 nums 执行 k 次操作，每次操作中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到 nums 中的 最小 值 x ，如果存在多个最小值，选择最 前面 的一个。&lt;/li&gt;
&lt;li&gt;将 x 替换为 x * multiplier 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请你返回执行完 k 次乘运算之后，最终的 nums 数组。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [2,1,3,5,6], k = 5, multiplier = 2&lt;/p&gt;
&lt;p&gt;输出：[8,4,6,5,6]&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;操作&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;结果&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;1 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[2, 2, 3, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;2 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[4, 2, 3, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;3 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[4, 4, 3, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;4 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[4, 4, 6, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;5 次操作后&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;[8, 4, 6, 5, 6]&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;</description>
    </item>
    <item>
      <title>2931_购买物品的最大开销</title>
      <link>https://loommii.github.io/posts/leetcode/data/2931_%E8%B4%AD%E4%B9%B0%E7%89%A9%E5%93%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%80%E9%94%80/</link>
      <pubDate>Thu, 12 Dec 2024 13:58:44 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/2931_%E8%B4%AD%E4%B9%B0%E7%89%A9%E5%93%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%80%E9%94%80/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/maximum-spending-after-buying-items/description/?envType=daily-question&amp;amp;envId=2024-12-12&#34;&gt;2931. 购买物品的最大开销&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;力扣难度 &lt;code&gt;困难&lt;/code&gt;
算法评级: 6   &lt;br&gt;
难度分 1822&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目:&lt;/p&gt;
&lt;p&gt;给你一个下标从 0 开始大小为 m * n 的整数矩阵 values ，表示 m 个不同商店里 m * n 件不同的物品。每个商店有 n 件物品，第 i 个商店的第 j 件物品的价值为 values[i][j] 。除此以外，第 i 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 0 &amp;lt;= j &amp;lt; n - 1 都有 values[i][j] &amp;gt;= values[i][j + 1] 。&lt;/p&gt;
&lt;p&gt;每一天，你可以在一个商店里购买一件物品。具体来说，在第 d 天，你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择商店 i 。&lt;/li&gt;
&lt;li&gt;购买数组中最右边的物品 j ，开销为 values[i][j] * d 。换句话说，选择该商店中还没购买过的物品中最大的下标 j ，并且花费 values[i][j] * d 去购买。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，所有物品都视为不同的物品。比方说如果你已经从商店 1 购买了物品 0 ，你还可以在别的商店里购买其他商店的物品 0 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>2717_半有序排列</title>
      <link>https://loommii.github.io/posts/leetcode/data/2717_%E5%8D%8A%E6%9C%89%E5%BA%8F%E6%8E%92%E5%88%97/</link>
      <pubDate>Wed, 11 Dec 2024 00:35:39 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/2717_%E5%8D%8A%E6%9C%89%E5%BA%8F%E6%8E%92%E5%88%97/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/semi-ordered-permutation/description/?envType=daily-question&amp;amp;envId=2024-12-11&#34;&gt;2717. 半有序排列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;
算法评级: 3      理解常用数据结构和算法
难度分 1296&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目:&lt;/p&gt;
&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始、长度为 &lt;code&gt;n&lt;/code&gt; 的整数排列 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果排列的第一个数字等于 &lt;code&gt;1&lt;/code&gt; 且最后一个数字等于 &lt;code&gt;n&lt;/code&gt;，则称其为 半有序排列 。你可以执行多次下述操作，直到将 &lt;code&gt;nums&lt;/code&gt; 变成一个 半有序排列 ：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [2,1,4,3]
输出：2
解释：可以依次执行下述操作得到半有序排列：
1 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。
2 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。
可以证明，要让 nums 成为半有序排列，不存在执行操作少于 2 次的方案。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [2,4,1,3]
输出：3
解释：
可以依次执行下述操作得到半有序排列：
1 - 交换下标 1 和下标 2 对应元素。排列变为 [2,1,4,3] 。
2 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。
3 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。
可以证明，要让 nums 成为半有序排列，不存在执行操作少于 3 次的方案。&lt;/p&gt;</description>
    </item>
    <item>
      <title>70_爬楼梯</title>
      <link>https://loommii.github.io/posts/leetcode/data/70_%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Wed, 11 Dec 2024 00:29:39 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/70_%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&amp;amp;envId=dynamic-programming&#34;&gt;70.爬楼梯&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;
算法评级: 2
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;1 阶 + 1 阶&lt;/li&gt;
&lt;li&gt;2 阶&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;1 阶 + 1 阶 + 1 阶&lt;/li&gt;
&lt;li&gt;1 阶 + 2 阶&lt;/li&gt;
&lt;li&gt;2 阶 + 1 阶&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;climbStairs&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;button class=&#34;toggle-button&#34; onclick=&#34;this.nextElementSibling.classList.toggle(&#39;show&#39;)&#34;&gt;🔑 答案解析： 👈点击&lt;/button&gt;
&lt;div class=&#34;toggle-content&#34;&gt;
  
&lt;/div&gt;
&lt;style&gt;
  .toggle-content {
    display: none;
    margin-top: 10px;
  }
  .toggle-content.show {
    display: block;
  }
&lt;/style&gt;</description>
    </item>
    <item>
      <title>935_骑士拨号器</title>
      <link>https://loommii.github.io/posts/leetcode/data/935_%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8/</link>
      <pubDate>Tue, 10 Dec 2024 20:20:24 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/935_%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/knight-dialer/description/?envType=daily-question&amp;amp;envId=2024-12-10&#34;&gt;935. 骑士拨号器&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;难度分-1690&#34;&gt;力扣难度 &lt;code&gt;中等&lt;/code&gt;
算法评级: 5      熟练掌握常用数据结构和算法，初步了解高级数据结构
难度分 1690&lt;/h2&gt;
&lt;p&gt;题目:&lt;/p&gt;
&lt;p&gt;象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。&lt;/p&gt;
&lt;p&gt;象棋骑士可能的移动方式如下图所示:
&lt;img alt=&#34;alt text&#34; loading=&#34;lazy&#34; src=&#34;https://loommii.github.io/posts/leetcode/data/935_%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8/image.png&#34;&gt;
我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。
&lt;img alt=&#34;alt text&#34; loading=&#34;lazy&#34; src=&#34;https://loommii.github.io/posts/leetcode/data/935_%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8/image-1.png&#34;&gt;
给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。&lt;/p&gt;
&lt;p&gt;你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。&lt;/p&gt;
&lt;p&gt;因为答案可能很大，所以输出答案模 109 + 7.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：n = 1
输出：10
解释：我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：n = 2
输出：20
解释：我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：n = 3131
输出：136006598
解释：注意取模&lt;/p&gt;</description>
    </item>
    <item>
      <title>1812_判断国际象棋棋盘中一个格子的颜色</title>
      <link>https://loommii.github.io/posts/leetcode/data/1812_%E5%88%A4%E6%96%AD%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%A3%8B%E7%9B%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E9%A2%9C%E8%89%B2/</link>
      <pubDate>Mon, 09 Dec 2024 12:14:07 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/1812_%E5%88%A4%E6%96%AD%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%A3%8B%E7%9B%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E9%A2%9C%E8%89%B2/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/determine-color-of-a-chessboard-square/description/?envType=daily-question&amp;amp;envId=2024-12-09&#34;&gt;1812. 判断国际象棋棋盘中一个格子的颜色&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;力扣难度 &lt;code&gt;简单&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目:
给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;棋盘&#34; loading=&#34;lazy&#34; src=&#34;https://loommii.github.io/posts/leetcode/data/1812_%E5%88%A4%E6%96%AD%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%A3%8B%E7%9B%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E9%A2%9C%E8%89%B2/chessboard.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。&lt;/p&gt;
&lt;p&gt;给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：coordinates = &amp;ldquo;a1&amp;rdquo;
输出：false
解释：如上图棋盘所示，&amp;ldquo;a1&amp;rdquo; 坐标的格子是黑色的，所以返回 false 。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：coordinates = &amp;ldquo;h3&amp;rdquo;
输出：true
解释：如上图棋盘所示，&amp;ldquo;h3&amp;rdquo; 坐标的格子是白色的，所以返回 true 。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：coordinates = &amp;ldquo;c7&amp;rdquo;
输出：false&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;squareIsWhite&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;coordinates&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;button class=&#34;toggle-button&#34; onclick=&#34;this.nextElementSibling.classList.toggle(&#39;show&#39;)&#34;&gt;🔑 答案解析： 👈点击&lt;/button&gt;
&lt;div class=&#34;toggle-content&#34;&gt;
  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;squareIsWhite&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;coordinates&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;coordinates&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;coordinates&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;style&gt;
  .toggle-content {
    display: none;
    margin-top: 10px;
  }
  .toggle-content.show {
    display: block;
  }
&lt;/style&gt;</description>
    </item>
    <item>
      <title>688_骑士在棋盘上的概率</title>
      <link>https://loommii.github.io/posts/leetcode/data/688_%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Sat, 07 Dec 2024 01:15:09 +0800</pubDate>
      <guid>https://loommii.github.io/posts/leetcode/data/688_%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>&lt;p&gt;力扣链接:&lt;a href=&#34;https://leetcode.cn/problems/knight-probability-in-chessboard/description/?envType=daily-question&amp;amp;envId=2024-12-07&#34;&gt;688. 骑士在棋盘上的概率&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;力扣难度 &lt;code&gt;中等&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;题目:&lt;/p&gt;
&lt;p&gt;在一个 &lt;code&gt;n x n&lt;/code&gt; 的国际象棋棋盘上，一个骑士从单元格 &lt;code&gt;(row, column)&lt;/code&gt; 开始，并尝试进行 &lt;code&gt;k&lt;/code&gt; 次移动。行和列是 从 &lt;code&gt;0&lt;/code&gt; 开始 的，所以左上单元格是 &lt;code&gt;(0,0)&lt;/code&gt; ，右下单元格是 &lt;code&gt;(n - 1, n - 1)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格
&lt;img alt=&#34;象棋骑士&#34; loading=&#34;lazy&#34; src=&#34;https://loommii.github.io/posts/leetcode/data/688_%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/knight.png&#34;&gt;
每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。&lt;/p&gt;
&lt;p&gt;骑士继续移动，直到它走了 &lt;code&gt;k&lt;/code&gt; 步或离开了棋盘。&lt;/p&gt;
&lt;p&gt;返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: n = 3, k = 2, row = 0, column = 0
输出: 0.0625
解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。
在每一个位置上，也有两种移动可以让骑士留在棋盘上。
骑士留在棋盘上的总概率是0.0625。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: n = 1, k = 0, row = 0, column = 0
输出: 1.00000&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
