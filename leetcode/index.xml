<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>力扣 on </title>
    <link>/leetcode/</link>
    <description>Recent content in 力扣 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 16 Feb 2025 23:49:25 +0800</lastBuildDate><atom:link href="/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1299_将每个元素替换为右侧最大元素</title>
      <link>/posts/leetcode/data/1299_%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 16 Feb 2025 23:49:25 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1299_%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>力扣链接: 1299. 将每个元素替换为右侧最大元素
 力扣难度 简单
算法评级: 3 理解常用数据结构和算法
难度分 1219
  题目:
给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。
完成所有替换操作后，请你返回这个数组。
 示例 1：
 输入：arr = [17,18,5,4,6,1] 输出：[18,6,6,6,1,-1] 解释：
 下标 0 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 1 的元素 (18) 下标 1 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 4 的元素 (6) 下标 2 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 4 的元素 (6) 下标 3 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 4 的元素 (6) 下标 4 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 5 的元素 (1) 下标 5 的元素 &amp;ndash;&amp;gt; 右侧没有其他元素，替换为 -1   示例 2：</description>
    </item>
    
    <item>
      <title>2264_字符串中最大的3位相同数字</title>
      <link>/posts/leetcode/data/2264_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%843%E4%BD%8D%E7%9B%B8%E5%90%8C%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 08 Jan 2025 14:00:23 +0800</pubDate>
      
      <guid>/posts/leetcode/data/2264_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%843%E4%BD%8D%E7%9B%B8%E5%90%8C%E6%95%B0%E5%AD%97/</guid>
      <description>力扣链接:2264. 字符串中最大的 3 位相同数字
 力扣难度 简单
算法评级: 2
难度分 1309
  题目：
给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ：
 该整数是 num 的一个长度为 3 的 子字符串 。 该整数由唯一一个数字重复 3 次组成。  以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 &amp;quot;&amp;quot; 。
注意：
 子字符串 是字符串中的一个连续字符序列。 num 或优质整数中可能存在 前导零 。  示例 1：
 输入：num = &amp;ldquo;6777133339&amp;rdquo;
输出：&amp;ldquo;777&amp;rdquo;
解释：num 中存在两个优质整数：&amp;ldquo;777&amp;rdquo; 和 &amp;ldquo;333&amp;rdquo; 。
&amp;ldquo;777&amp;rdquo; 是最大的那个，所以返回 &amp;ldquo;777&amp;rdquo; 。
 示例 2：
 输入：num = &amp;ldquo;2300019&amp;rdquo;
输出：&amp;ldquo;000&amp;rdquo;
解释：&amp;ldquo;000&amp;rdquo; 是唯一一个优质整数。</description>
    </item>
    
    <item>
      <title>3019_按键变更的次数</title>
      <link>/posts/leetcode/data/3019_%E6%8C%89%E9%94%AE%E5%8F%98%E6%9B%B4%E7%9A%84%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Tue, 07 Jan 2025 21:47:21 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3019_%E6%8C%89%E9%94%AE%E5%8F%98%E6%9B%B4%E7%9A%84%E6%AC%A1%E6%95%B0/</guid>
      <description>力扣链接:3019. 按键变更的次数
力扣难度 简单 算法评级: 2 知道常用数据结构和算法并简单使用 难度分 1176
 题目:
给你一个下标从 0 开始的字符串 s ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 s = &amp;ldquo;ab&amp;rdquo; 表示按键变更一次，而 s = &amp;ldquo;bBBb&amp;rdquo; 不存在按键变更。
返回用户输入过程中按键变更的次数。
注意：shift 或 caps lock 等修饰键不计入按键变更，也就是说，如果用户先输入字母 &amp;lsquo;a&amp;rsquo; 然后输入字母 &amp;lsquo;A&amp;rsquo; ，不算作按键变更。
示例 1：
 输入：s = &amp;ldquo;aAbBcC&amp;rdquo;
输出：2
解释：
从 s[0] = &amp;lsquo;a&amp;rsquo; 到 s[1] = &amp;lsquo;A&amp;rsquo;，不存在按键变更，因为不计入 caps lock 或 shift 。
从 s[1] = &amp;lsquo;A&amp;rsquo; 到 s[2] = &amp;lsquo;b&amp;rsquo;，按键变更。
从 s[2] = &amp;lsquo;b&amp;rsquo; 到 s[3] = &amp;lsquo;B&amp;rsquo;，不存在按键变更，因为不计入 caps lock 或 shift 。</description>
    </item>
    
    <item>
      <title>3083_字符串及其反转中是否存在同一子字符串</title>
      <link>/posts/leetcode/data/3083_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E5%8F%8D%E8%BD%AC%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%90%8C%E4%B8%80%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 28 Dec 2024 18:04:37 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3083_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E5%8F%8D%E8%BD%AC%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%90%8C%E4%B8%80%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>力扣链接:3083. 字符串及其反转中是否存在同一子字符串
 力扣难度 简单
算法评级: 2 知道常用数据结构和算法并简单使用
难度分 1173
  题目：
给你一个字符串 s ，请你判断字符串 s 是否存在一个长度为 2 的子字符串，在其反转后的字符串中也出现。
如果存在这样的子字符串，返回 true；如果不存在，返回 false 。
示例 1：
 输入：s = &amp;ldquo;leetcode&amp;rdquo;
输出：true
解释：子字符串 &amp;ldquo;ee&amp;rdquo; 的长度为 2，它也出现在 reverse(s) == &amp;ldquo;edocteel&amp;rdquo; 中。
 示例 2：
 输入：s = &amp;ldquo;abcba&amp;rdquo;
输出：true
解释：所有长度为 2 的子字符串 &amp;ldquo;ab&amp;rdquo;、&amp;ldquo;bc&amp;rdquo;、&amp;ldquo;cb&amp;rdquo;、&amp;ldquo;ba&amp;rdquo; 也都出现在 reverse(s) == &amp;ldquo;abcba&amp;rdquo; 中。
 示例 3：
 输入：s = &amp;ldquo;abcd&amp;rdquo;
输出：false
解释：字符串 s 中不存在满足「在其反转后的字符串中也出现」且长度为 2 的子字符串。
  func isSubstringPresent(s string) bool { }  🔑 答案解析： 👈点击// isSubstringPresent 函数用于判断给定字符串 s 中是否存在一对字符的子串， // 这对字符以相反的顺序也出现过。 func isSubstringPresent(s string) bool { // 创建一个 26×26 的布尔数组 vis，用于记录每对字符是否出现过。  // 索引的含义是：vis[x][y] 表示字符 x 和字符 y 组成的子串是否出现过。  // 这里的 x 和 y 是字符在字母表中的索引，从 0 到 25 分别对应 &amp;#39;a&amp;#39; 到 &amp;#39;z&amp;#39;。  vis := [26][26]bool{} // 遍历字符串 s，从第二个字符开始，因为要检查相邻的两个字符组成的子串。  for i := 1; i &amp;lt; len(s); i++ { // 计算当前字符对中第一个字符在字母表中的索引。  // 例如，如果字符是 &amp;#39;a&amp;#39;，则 x 为 0；如果是 &amp;#39;b&amp;#39;，则 x 为 1，以此类推。  x := s[i-1] - &amp;#39;a&amp;#39; // 计算当前字符对中第二个字符在字母表中的索引。  y := s[i] - &amp;#39;a&amp;#39; // 将当前字符对标记为已出现过。  vis[x][y] = true // 检查是否存在相反顺序的字符对。  // 如果 vis[y][x] 为 true，说明字符 y 和字符 x 组成的子串也出现过，  // 即找到了满足条件的子串，返回 true。  if vis[y][x] { return true } } // 如果遍历完整个字符串都没有找到满足条件的子串，返回 false。  return false } .</description>
    </item>
    
    <item>
      <title>3159_查询数组中元素的出现位置</title>
      <link>/posts/leetcode/data/3159_%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Sat, 28 Dec 2024 14:28:22 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3159_%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE/</guid>
      <description>力扣链接:3159. 查询数组中元素的出现位置
 力扣难度 中等
算法评级: 2 知道常用数据结构和算法并简单使用
难度分 1263
  题目： 给你一个整数数组 nums ，一个整数数组 queries 和一个整数 x 。
对于每个查询 queries[i] ，你需要找到 nums 中第 queries[i] 个 x 的位置，并返回它的下标。如果数组中 x 的出现次数少于 queries[i] ，该查询的答案为 -1 。
请你返回一个整数数组 answer ，包含所有查询的答案。
示例 1：
 输入：nums = [1,3,1,7], queries = [1,3,2,4], x = 1
输出：[0,-1,2,-1]
解释：
 第 1 个查询，第一个 1 出现在下标 0 处。 第 2 个查询，nums 中只有两个 1 ，所以答案为 -1 。 第 3 个查询，第二个 1 出现在下标 2 处。 第 4 个查询，nums 中只有两个 1 ，所以答案为 -1 。   示例 2：</description>
    </item>
    
    <item>
      <title>3046_分割数组</title>
      <link>/posts/leetcode/data/3046_%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 28 Dec 2024 13:02:42 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3046_%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/</guid>
      <description>力扣链接:3046. 分割数组
 力扣难度 简单
算法评级: 2 知道常用数据结构和算法并简单使用
难度分 1212
  题目： 给你一个长度为 偶数 的整数数组 nums 。你需要将这个数组分割成 nums1 和 nums2 两部分，要求：
 nums1.length == nums2.length == nums.length / 2 。 nums1 应包含 互不相同 的元素。 nums2也应包含 互不相同 的元素。  如果能够分割数组就返回 true ，否则返回 false 。
示例 1：
 输入：nums = [1,1,2,2,3,4]
输出：true
解释：分割 nums 的可行方案之一是 nums1 = [1,2,3] 和 nums2 = [1,2,4] 。
 示例 2：
 输入：nums = [1,1,1,1]
输出：false</description>
    </item>
    
    <item>
      <title>3285_找到稳定山的下标</title>
      <link>/posts/leetcode/data/3285_%E6%89%BE%E5%88%B0%E7%A8%B3%E5%AE%9A%E5%B1%B1%E7%9A%84%E4%B8%8B%E6%A0%87/</link>
      <pubDate>Wed, 25 Dec 2024 15:05:58 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3285_%E6%89%BE%E5%88%B0%E7%A8%B3%E5%AE%9A%E5%B1%B1%E7%9A%84%E4%B8%8B%E6%A0%87/</guid>
      <description>力扣链接:3285. 找到稳定山的下标
 力扣难度 简单
算法评级: 1 无算法要求
难度分 1166
  有 n 座山排成一列，每座山都有一个高度。给你一个整数数组 height ，其中 height[i] 表示第 i 座山的高度，再给你一个整数 threshold 。
对于下标不为 0 的一座山，如果它左侧相邻的山的高度 严格大于 threshold ，那么我们称它是 稳定 的。我们定义下标为 0 的山 不是 稳定的。
请你返回一个数组，包含所有 稳定 山的下标，你可以以 任意 顺序返回下标数组。
 示例 1：
 输入：height = [1,2,3,4,5], threshold = 2
输出：[3,4]
解释：
下标为 3 的山是稳定的，因为 height[2] == 3 大于 threshold == 2 。 下标为 4 的山是稳定的，因为 height[3] == 4 大于 threshold == 2.</description>
    </item>
    
    <item>
      <title>1387_将整数按权重排序</title>
      <link>/posts/leetcode/data/1387_%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 22 Dec 2024 15:09:23 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1387_%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/</guid>
      <description>力扣链接:1387. 将整数按权重排序
 力扣难度 中等
算法评级: 6 深入理解并灵活应用数据结构和算法，理解高级数据结构
难度分 1507
  题目：
我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：
 如果 x 是偶数，那么 x = x / 2 如果 x 是奇数，那么 x = 3 * x + 1  比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 &amp;ndash;&amp;gt; 10 &amp;ndash;&amp;gt; 5 &amp;ndash;&amp;gt; 16 &amp;ndash;&amp;gt; 8 &amp;ndash;&amp;gt; 4 &amp;ndash;&amp;gt; 2 &amp;ndash;&amp;gt; 1）。
给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。</description>
    </item>
    
    <item>
      <title>2545_根据第K场考试的分数排序</title>
      <link>/posts/leetcode/data/2545_%E6%A0%B9%E6%8D%AE%E7%AC%ACk%E5%9C%BA%E8%80%83%E8%AF%95%E7%9A%84%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 21 Dec 2024 13:47:52 +0800</pubDate>
      
      <guid>/posts/leetcode/data/2545_%E6%A0%B9%E6%8D%AE%E7%AC%ACk%E5%9C%BA%E8%80%83%E8%AF%95%E7%9A%84%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>力扣链接:2545. 根据第 K 场考试的分数排序
 力扣难度 中等
算法评级: 3 理解常用数据结构和算法
难度分 1294
  题目：
班里有 m 位学生，共计划组织 n 场考试。给你一个下标从 0 开始、大小为 m x n 的整数矩阵 score ，其中每一行对应一位学生，而 score[i][j] 表示第 i 位学生在第 j 场考试取得的分数。矩阵 score 包含的整数 互不相同 。
另给你一个整数 k 。请你按第 k 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。
返回排序后的矩阵。
示例 1：  输入：score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2 输出：[[7,5,11,2],[10,6,9,1],[4,8,3,15]]
解释：在上图中，S 表示学生，E 表示考试。
 下标为 1 的学生在第 2 场考试取得的分数为 11 ，这是考试的最高分，所以 TA 需要排在第一。 下标为 0 的学生在第 2 场考试取得的分数为 9 ，这是考试的第二高分，所以 TA 需要排在第二。 下标为 2 的学生在第 2 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第三。   示例 2：  输入：score = [[3,4],[5,6]], k = 0 输出：[[5,6],[3,4]] 解释：在上图中，S 表示学生，E 表示考试。</description>
    </item>
    
    <item>
      <title>3138_同位字符串连接的最小长度</title>
      <link>/posts/leetcode/data/3138_%E5%90%8C%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Fri, 20 Dec 2024 23:57:43 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3138_%E5%90%8C%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6/</guid>
      <description>力扣链接:3138. 同位字符串连接的最小长度
 力扣难度 中等
算法评级: 5 熟练掌握常用数据结构和算法，初步了解高级数据结构 难度分 1979
  题目:
给你一个字符串 s ，它由某个字符串 t 和若干 t 的 同位字符串 连接而成。
请你返回字符串 t 的 最小 可能长度。
同位字符串 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。
示例 1：
 输入：s = &amp;ldquo;abba&amp;rdquo;
输出：2
解释：
一个可能的字符串 t 为 &amp;ldquo;ba&amp;rdquo; 。
 示例 2：
 输入：s = &amp;ldquo;cdef&amp;rdquo;
输出：4
解释：
一个可能的字符串 t 为 &amp;ldquo;cdef&amp;rdquo; ，注意 t 可能等于 s 。
 提示：
 1 &amp;lt;= s.length &amp;lt;= 105 s 只包含小写英文字母。   func minAnagramLength(s string) int { }  🧠思路: 👈点击枚举 设 s字符串的长度为n,阅读题目可得提供的s一定是由 字符串 t构成的。(有确定的结)</description>
    </item>
    
    <item>
      <title>3291_形成目标字符串需要的最少字符串数_I</title>
      <link>/posts/leetcode/data/3291_%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0_i/</link>
      <pubDate>Tue, 17 Dec 2024 14:34:51 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3291_%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0_i/</guid>
      <description>力扣链接:3291. 形成目标字符串需要的最少字符串数 I
 力扣难度 中等
算法评级: 6 深入理解并灵活应用数据结构和算法，理解高级数据结构
难度分 2082
  题目: 给你一个字符串数组 words 和一个字符串 target。
如果字符串 x 是 words 中 任意 字符串的 前缀 ，则认为 x 是一个 有效 字符串。
现计划通过 连接 有效字符串形成 target ，请你计算并返回需要连接的 最少 字符串数量。如果无法通过这种方式形成 target，则返回 -1。
示例 1：
 输入： words = [&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;aaaaa&amp;rdquo;,&amp;ldquo;bcdef&amp;rdquo;], target = &amp;ldquo;aabcdabc&amp;rdquo;
输出： 3
解释：
target 字符串可以通过连接以下有效字符串形成：
 words[1] 的长度为 2 的前缀，即 &amp;ldquo;aa&amp;rdquo;。 words[2] 的长度为 3 的前缀，即 &amp;ldquo;bcd&amp;rdquo;。 words[0] 的长度为 3 的前缀，即 &amp;ldquo;abc&amp;rdquo;。   示例 2：</description>
    </item>
    
    <item>
      <title>1847_最近的房间</title>
      <link>/posts/leetcode/data/1847_%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%BF%E9%97%B4/</link>
      <pubDate>Mon, 16 Dec 2024 14:28:52 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1847_%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%BF%E9%97%B4/</guid>
      <description>力扣链接:1847. 最近的房间
 力扣难度 困难
算法评级: 8 掌握不同的数据结构与算法之间的关联性，处理复杂问题，掌握高级数据结构
难度分 2082
  题目：
一个酒店里有 n 个房间，这些房间用二维整数数组 rooms 表示，其中 rooms[i] = [roomIdi, sizei] 表示有一个房间号为 roomIdi 的房间且它的面积为 sizei 。每一个房间号 roomIdi 保证是 独一无二 的。
同时给你 k 个查询，用二维数组 queries 表示，其中 queries[j] = [preferredj, minSizej] 。第 j 个查询的答案是满足如下条件的房间 id ：
 房间的面积 至少 为 minSizej ，且abs(id - preferredj) 的值 最小 ，其中 abs(x) 是 x 的绝对值。  如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。</description>
    </item>
    
    <item>
      <title>1338_数组大小减半</title>
      <link>/posts/leetcode/data/1338_%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A/</link>
      <pubDate>Sun, 15 Dec 2024 15:36:23 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1338_%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A/</guid>
      <description>力扣链接:1338. 数组大小减半
力扣难度 中等
算法评级: 3 理解常用数据结构和算法
难度分 1303
 题目: 给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。
返回 至少 能删除数组中的一半整数的整数集合的最小大小
示例 1：
 输入：arr = [3,3,3,3,5,5,5,2,2,7] 输出：2 解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。 大小为 2 的可行集合有 {3,5},{3,2},{5,2}。 选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。
 示例 2：
 输入：arr = [7,7,7,7,7,7] 输出：1 解释：我们只能选择集合 {7}，结果数组为空。
 提示：
 1 &amp;lt;= arr.length &amp;lt;= 105 arr.length 为偶数 1 &amp;lt;= arr[i] &amp;lt;= 105   func minSetSize(arr []int) int { }  🧠思路: 👈点击猜想 贪心的想法，先遍历一遍记录出现次数。从频率最高的开始删除 问题就变为了怎么记录次数后从大到小排序方便.</description>
    </item>
    
    <item>
      <title>3266_K_次乘运算后的最终数组_II</title>
      <link>/posts/leetcode/data/3266_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_ii/</link>
      <pubDate>Sat, 14 Dec 2024 12:13:03 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3266_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_ii/</guid>
      <description>力扣链接:3264. K 次乘运算后的最终数组 I
力扣难度 困难
算法评级: 8 掌握不同的数据结构与算法之间的关联性，处理复杂问题，掌握高级数据结构
难度分 2509
 题目: 给你一个整数数组 nums ，一个整数 k 和一个整数 multiplier 。
你需要对 nums 执行 k 次操作，每次操作中：
 找到 nums 中的 最小 值 x ，如果存在多个最小值，选择最 前面 的一个 将 x 替换为 x * multiplier 。  k 次操作以后，你需要将 nums 中每一个数值对 109 + 7 取余。 请你返回执行完 k 次乘运算以及取余运算之后，最终的 nums 数组。
示例 1：
 输入：nums = [2,1,3,5,6], k = 5, multiplier = 2
输出：[8,4,6,5,6]
解释：</description>
    </item>
    
    <item>
      <title>3264_K_次乘运算后的最终数组_I</title>
      <link>/posts/leetcode/data/3264_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_i/</link>
      <pubDate>Fri, 13 Dec 2024 15:58:17 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3264_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_i/</guid>
      <description>力扣链接:3264. K 次乘运算后的最终数组 I
力扣难度 简单
算法评级: 3 理解常用数据结构和算法
难度分 1178
 题目: 给你一个整数数组 nums ，一个整数 k 和一个整数 multiplier 。
你需要对 nums 执行 k 次操作，每次操作中：
 找到 nums 中的 最小 值 x ，如果存在多个最小值，选择最 前面 的一个。 将 x 替换为 x * multiplier 。  请你返回执行完 k 次乘运算之后，最终的 nums 数组。
示例 1：
 输入：nums = [2,1,3,5,6], k = 5, multiplier = 2
输出：[8,4,6,5,6]
解释：
   操作 结果     1 次操作后 [2, 2, 3, 5, 6]   2 次操作后 [4, 2, 3, 5, 6]   3 次操作后 [4, 4, 3, 5, 6]   4 次操作后 [4, 4, 6, 5, 6]   5 次操作后 [8, 4, 6, 5, 6]     示例 2：</description>
    </item>
    
    <item>
      <title>2931_购买物品的最大开销</title>
      <link>/posts/leetcode/data/2931_%E8%B4%AD%E4%B9%B0%E7%89%A9%E5%93%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%80%E9%94%80/</link>
      <pubDate>Thu, 12 Dec 2024 13:58:44 +0800</pubDate>
      
      <guid>/posts/leetcode/data/2931_%E8%B4%AD%E4%B9%B0%E7%89%A9%E5%93%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%80%E9%94%80/</guid>
      <description>力扣链接:2931. 购买物品的最大开销
力扣难度 困难 算法评级: 6 难度分 1822
 题目:
给你一个下标从 0 开始大小为 m * n 的整数矩阵 values ，表示 m 个不同商店里 m * n 件不同的物品。每个商店有 n 件物品，第 i 个商店的第 j 件物品的价值为 values[i][j] 。除此以外，第 i 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 0 &amp;lt;= j &amp;lt; n - 1 都有 values[i][j] &amp;gt;= values[i][j + 1] 。
每一天，你可以在一个商店里购买一件物品。具体来说，在第 d 天，你可以：
 选择商店 i 。 购买数组中最右边的物品 j ，开销为 values[i][j] * d 。换句话说，选择该商店中还没购买过的物品中最大的下标 j ，并且花费 values[i][j] * d 去购买。  注意，所有物品都视为不同的物品。比方说如果你已经从商店 1 购买了物品 0 ，你还可以在别的商店里购买其他商店的物品 0 。</description>
    </item>
    
    <item>
      <title>2717_半有序排列</title>
      <link>/posts/leetcode/data/2717_%E5%8D%8A%E6%9C%89%E5%BA%8F%E6%8E%92%E5%88%97/</link>
      <pubDate>Wed, 11 Dec 2024 00:35:39 +0800</pubDate>
      
      <guid>/posts/leetcode/data/2717_%E5%8D%8A%E6%9C%89%E5%BA%8F%E6%8E%92%E5%88%97/</guid>
      <description>力扣链接:2717. 半有序排列
力扣难度 简单 算法评级: 3 理解常用数据结构和算法 难度分 1296
 题目:
给你一个下标从 0 开始、长度为 n 的整数排列 nums 。
如果排列的第一个数字等于 1 且最后一个数字等于 n，则称其为 半有序排列 。你可以执行多次下述操作，直到将 nums 变成一个 半有序排列 ：
 示例 1：
 输入：nums = [2,1,4,3] 输出：2 解释：可以依次执行下述操作得到半有序排列： 1 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。 2 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。 可以证明，要让 nums 成为半有序排列，不存在执行操作少于 2 次的方案。
 示例 2：
 输入：nums = [2,4,1,3] 输出：3 解释： 可以依次执行下述操作得到半有序排列： 1 - 交换下标 1 和下标 2 对应元素。排列变为 [2,1,4,3] 。 2 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。 3 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。 可以证明，要让 nums 成为半有序排列，不存在执行操作少于 3 次的方案。</description>
    </item>
    
    <item>
      <title>70_爬楼梯</title>
      <link>/posts/leetcode/data/70_%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Wed, 11 Dec 2024 00:29:39 +0800</pubDate>
      
      <guid>/posts/leetcode/data/70_%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>力扣链接:70.爬楼梯
力扣难度 简单 算法评级: 2 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 示例 1：
 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。
  1 阶 + 1 阶 2 阶  示例 2：
 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。
  1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶   func climbStairs(n int) int { }  🔑 答案解析： 👈点击.</description>
    </item>
    
    <item>
      <title>935_骑士拨号器</title>
      <link>/posts/leetcode/data/935_%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8/</link>
      <pubDate>Tue, 10 Dec 2024 20:20:24 +0800</pubDate>
      
      <guid>/posts/leetcode/data/935_%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8/</guid>
      <description>力扣链接:935. 骑士拨号器
力扣难度 中等 算法评级: 5 熟练掌握常用数据结构和算法，初步了解高级数据结构 难度分 1690 题目:
象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。
象棋骑士可能的移动方式如下图所示: 我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。 给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。
你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。
因为答案可能很大，所以输出答案模 109 + 7.
 示例 1：
 输入：n = 1 输出：10 解释：我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。
 示例 2：
 输入：n = 2 输出：20 解释：我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]
 示例 3：</description>
    </item>
    
    <item>
      <title>1812_判断国际象棋棋盘中一个格子的颜色</title>
      <link>/posts/leetcode/data/1812_%E5%88%A4%E6%96%AD%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%A3%8B%E7%9B%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E9%A2%9C%E8%89%B2/</link>
      <pubDate>Mon, 09 Dec 2024 12:14:07 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1812_%E5%88%A4%E6%96%AD%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%A3%8B%E7%9B%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E9%A2%9C%E8%89%B2/</guid>
      <description>力扣链接:1812. 判断国际象棋棋盘中一个格子的颜色
力扣难度 简单
 题目: 给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。
如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。
给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。
示例 1：
 输入：coordinates = &amp;ldquo;a1&amp;rdquo; 输出：false 解释：如上图棋盘所示，&amp;ldquo;a1&amp;rdquo; 坐标的格子是黑色的，所以返回 false 。
 示例 2：
 输入：coordinates = &amp;ldquo;h3&amp;rdquo; 输出：true 解释：如上图棋盘所示，&amp;ldquo;h3&amp;rdquo; 坐标的格子是白色的，所以返回 true 。
 示例 3：
 输入：coordinates = &amp;ldquo;c7&amp;rdquo; 输出：false
  func squareIsWhite(coordinates string) bool { } 🔑 答案解析： 👈点击func squareIsWhite(coordinates string) bool { return coordinates[0]%2 != coordinates[1]%2 } .toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>688_骑士在棋盘上的概率</title>
      <link>/posts/leetcode/data/688_%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Sat, 07 Dec 2024 01:15:09 +0800</pubDate>
      
      <guid>/posts/leetcode/data/688_%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>力扣链接:688. 骑士在棋盘上的概率
力扣难度 中等
 题目:
在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。
象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格 每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。
骑士继续移动，直到它走了 k 步或离开了棋盘。
返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。
 示例 1：
 输入: n = 3, k = 2, row = 0, column = 0 输出: 0.0625 解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。 在每一个位置上，也有两种移动可以让骑士留在棋盘上。 骑士留在棋盘上的总概率是0.0625。
 示例 2：
 输入: n = 1, k = 0, row = 0, column = 0 输出: 1.</description>
    </item>
    
  </channel>
</rss>
