<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 16 Feb 2025 23:49:25 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1299_将每个元素替换为右侧最大元素</title>
      <link>/posts/leetcode/data/1299_%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 16 Feb 2025 23:49:25 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1299_%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>力扣链接: 1299. 将每个元素替换为右侧最大元素
 力扣难度 简单
算法评级: 3 理解常用数据结构和算法
难度分 1219
  题目:
给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。
完成所有替换操作后，请你返回这个数组。
 示例 1：
 输入：arr = [17,18,5,4,6,1] 输出：[18,6,6,6,1,-1] 解释：
 下标 0 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 1 的元素 (18) 下标 1 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 4 的元素 (6) 下标 2 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 4 的元素 (6) 下标 3 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 4 的元素 (6) 下标 4 的元素 &amp;ndash;&amp;gt; 右侧最大元素是下标 5 的元素 (1) 下标 5 的元素 &amp;ndash;&amp;gt; 右侧没有其他元素，替换为 -1   示例 2：</description>
    </item>
    
    <item>
      <title>Go每日一题_179</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_179/</link>
      <pubDate>Sat, 08 Feb 2025 22:46:18 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_179/</guid>
      <description>下面这段代码输出什么？
package main import &amp;#34;fmt&amp;#34; func main() { var a = []int{1, 2, 3, 4, 5} var r [5]int for i, v := range a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(&amp;#34;r = &amp;#34;, r) fmt.Println(&amp;#34;a = &amp;#34;, a) } 🔑 答案解析：r = [1 12 13 4 5]a = [1 12 13 4 5]Go在线运行
遍历的虽然是a的副本，但是在不发生扩容的情况下，副本和a指向的都是同一个底层数组，因此可以修改到a的内容
.</description>
    </item>
    
    <item>
      <title>Go每日一题_178</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_178/</link>
      <pubDate>Fri, 07 Feb 2025 00:45:26 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_178/</guid>
      <description>下面这段代码输出什么？
package main import &amp;#34;fmt&amp;#34; func change(s ...int) { s = append(s, 3) } func main() { slice := make([]int, 5, 5) slice[0] = 1 slice[1] = 2 change(slice...) fmt.Println(slice) change(slice[0:2]...) fmt.Println(slice) } 🔑 答案解析：[1 2 0 0 0][1 2 3 0 0]Go在线运行
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_177</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_177/</link>
      <pubDate>Thu, 06 Feb 2025 00:45:26 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_177/</guid>
      <description>下面这段代码输出什么？
package main import &amp;#34;fmt&amp;#34; func main() { var a = [5]int{1, 2, 3, 4, 5} var r [5]int for i, v := range a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(&amp;#34;r = &amp;#34;, r) fmt.Println(&amp;#34;a = &amp;#34;, a) } 🔑 答案解析：r = [1 2 3 4 5]a = [1 12 13 4 5]Go在线运行
数组的 range 行为：当使用 range 遍历数组时，Go 会先创建原数组的副本，遍历的是这个副本。因此，循环中对原数组的修改不会影响迭代中的值。</description>
    </item>
    
    <item>
      <title>Go每日一题_176</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_176/</link>
      <pubDate>Wed, 05 Feb 2025 00:45:26 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_176/</guid>
      <description>下面这段代码输出什么？为什么？
package main import &amp;#34;fmt&amp;#34; type People interface { Show() } type Student struct{} func (stu *Student) Show() { } func main() { var s *Student if s == nil { fmt.Println(&amp;#34;s is nil&amp;#34;) } else { fmt.Println(&amp;#34;s is not nil&amp;#34;) } var p People = s if p == nil { fmt.Println(&amp;#34;p is nil&amp;#34;) } else { fmt.Println(&amp;#34;p is not nil&amp;#34;) } } 🔑 答案解析：s is nilp is not nil 记住一点，当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。</description>
    </item>
    
    <item>
      <title>Go每日一题_175</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_175/</link>
      <pubDate>Tue, 04 Feb 2025 00:45:22 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_175/</guid>
      <description>下面这段代码输出什么？
package main import &amp;#34;fmt&amp;#34; const ( a = iota b = iota ) const ( name = &amp;#34;name&amp;#34; c = iota d = iota ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) } 🔑 答案解析：0112在线运行
代码解析：
第一个 const 块：  a = iota: iota 在 const 块中从 0 开始计数，因此 a = 0 b = iota: iota 自增到 1，因此 b = 1  第二个 const 块：  name = &amp;quot;name&amp;quot;: 未使用 iota，但 iota 初始值为 0，声明后自增到 1 c = iota: 当前 iota 值为 1，因此 c = 1 d = iota: iota 继续自增到 2，因此 d = 2  关键规则：  iota 在每个 const 块中从 0 开始计数 每行常量声明（无论是否使用 iota）都会使 iota 自增 1 不同 const 块的 iota 相互独立  .</description>
    </item>
    
    <item>
      <title>Go每日一题_174</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_174/</link>
      <pubDate>Tue, 28 Jan 2025 10:15:27 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_174/</guid>
      <description>下面这段代码输出什么？为什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { s1 := []int{1, 2, 3} s2 := s1[1:] s2[1] = 4 fmt.Println(s1) s2 = append(s2, 5, 6, 7) fmt.Println(s2) } 🔑 答案解析：[1 2 4] [2 4 5 6 7] 在线运行
切片共享底层数组：  s1 初始化为 []int{1, 2, 3}，底层数组为 [1, 2, 3]，长度和容量均为 3。 s2 := s1[1:] 创建了 s1 的子切片。此时：  s2 的底层数组与 s1 相同。 s2 的起始索引为 1，长度为 2（元素为 [2, 3]），容量为 2（原切片容量 3 - 起始索引 1 = 2）。    修改共享元素：  s2[1] = 4 修改的是底层数组的第三个元素（索引 2）。由于 s1 和 s2 共享底层数组，s1 变为 [1, 2, 4]。  append 触发扩容：  s2 = append(s2, 5, 6, 7) 时，原容量 2 不足以容纳 5 个元素（原长度 2 + 3 个新增元素），触发扩容。 扩容后，s2 的底层数组变为全新的数组，与原 s1 完全独立。 新 s2 的元素为 [2, 4, 5, 6, 7]，而 s1 不受影响。  .</description>
    </item>
    
    <item>
      <title>Go每日一题_173</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_173/</link>
      <pubDate>Mon, 27 Jan 2025 10:05:59 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_173/</guid>
      <description>下面这段代码输出什么？为什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { s1 := []int{1, 2, 3} s2 := s1[1:] s2[1] = 4 fmt.Println(s1) s2 = append(s2, 5, 6, 7) fmt.Println(s1) } 🔑 答案解析：[1 2 4] [1 2 4] 在线运行
切片共享底层数组   初始化切片 s1：
 s1 初始化为 []int{1, 2, 3}，底层数组容量为 3。    创建新切片 s2：
 s2 := s1[1:] 创建了一个新切片，起始索引为 1，长度为 2（元素为 2, 3），容量为 2（原数组容量 3 减去起始索引 1）。    修改共享元素：</description>
    </item>
    
    <item>
      <title>Go每日一题_172</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_172/</link>
      <pubDate>Sun, 26 Jan 2025 21:19:16 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_172/</guid>
      <description>下面的代码有几处语法问题，各是什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { var x string = nil if x == nil { x = &amp;#34;default&amp;#34; } fmt.Println(x) } 🔑 答案解析：./prog.go:8:17: cannot use nil as string value in variable declaration./prog.go:9:10: invalid operation: x == nil (mismatched types string and untyped nil)var x string = nil 错误： 在 Go 语言中，string 类型的零值是空字符串 &amp;quot;&amp;quot;，而不是 nil。nil 通常用于指针、切片、映射、通道、接口等类型。因此，将 nil 赋值给 string 类型的变量 x 会导致编译错误。
正确的写法应该是：var x string 或 var x string = &amp;quot;&amp;quot;。</description>
    </item>
    
    <item>
      <title>Go每日一题_171</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_171/</link>
      <pubDate>Sat, 25 Jan 2025 23:19:23 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_171/</guid>
      <description>date: &amp;lsquo;2025-01-23T15:36:46+08:00&amp;rsquo; draft: false title: &amp;lsquo;Go每日一题_170&amp;rsquo; 以下代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { var ans float64 = 15 + 25 + 5.2 fmt.Println(ans) }  A：不能编译； B：45； C：45.2； D：45.0  🔑 答案解析：C 在线运行
解析 1. 常量表达式  常量表达式是指仅包含常量操作数，且在编译时进行计算的表达式。 常量可以是：  无类型常量（untyped constants）：例如 1、2、5.2。 有类型常量（typed constants）：例如 const b int8 = 3。 字面值常量：例如 1、2、5.2。 具名常量：例如 const a = 1 + 2。    2. 无类型常量的默认类型  无类型常量虽然没有明确的类型，但它们有一个默认类型：  整数型字面量（如 15、25）的默认类型是 int。 浮点数字面量（如 5.</description>
    </item>
    
    <item>
      <title>Go每日一题_170</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_170/</link>
      <pubDate>Thu, 23 Jan 2025 15:36:46 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_170/</guid>
      <description>date: &amp;lsquo;2025-01-23T15:36:46+08:00&amp;rsquo; draft: false title: &amp;lsquo;Go每日一题_170&amp;rsquo; A、B、C、D 哪些选项有语法错误？
type S struct { } func f(x interface{}) { } func g(x *interface{}) { } func main() { s := S{} p := &amp;amp;s f(s) //A 	g(s) //B 	f(p) //C 	g(p) //D } 🔑 答案解析：BD 在线运行
函数参数为 interface{} 时可以接收任何类型的参数，包括用户自定义类型等，即使是接收指针类型也用 interface{}，而不是使用 *interface{}。
 永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。
 参数为 *interface{} 时，只能接受空接口的指针，而不是任何类型
func g(x *interface{}) { } func main() { s := S{} p := &amp;amp;s f(s) //A 	var r interface{} = p g(&amp;amp;r) //D } 例如这样 D就不会报错了，但是不建议这样使用</description>
    </item>
    
    <item>
      <title>Go每日一题_169</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_169/</link>
      <pubDate>Wed, 22 Jan 2025 13:17:56 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_169/</guid>
      <description>下面的两个切片声明中有什么区别？哪个更可取？
A. var a []int B. a := []int{} 🔑 答案解析：A 声明的 []int 未初始化 指向的nil B 声明的 []int 是已经初始化的 指向的内容为空的数组。
A 可以写到全局 B 只能写到函数内
A 与 B 占用的内存空间理论上是相同的。 注意：空切片empty slice 指向了一个固定地址，所以实际上确实没有分配内存。
但是B比A 多指向的内容为空的数组，这个操作也会消耗而外性能(🤏),在性能的角度上A具有优势
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_168</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_168/</link>
      <pubDate>Tue, 21 Jan 2025 22:53:38 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_168/</guid>
      <description>下面代码输出什么？
package main import &amp;#34;fmt&amp;#34; type Person struct { age int } func main() { person := &amp;amp;Person{28} // 1. 	defer fmt.Println(person.age) // 2. 	defer func(p *Person) { fmt.Println(p.age) }(person) // 3. 	defer func() { fmt.Println(person.age) }() person = &amp;amp;Person{29} } 🔑 答案解析：292828在线运行
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_167</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_167/</link>
      <pubDate>Mon, 20 Jan 2025 21:36:34 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_167/</guid>
      <description>下面这段代码正确的输出是什么？
package main import &amp;#34;fmt&amp;#34; func f() { defer fmt.Println(&amp;#34;D&amp;#34;) fmt.Println(&amp;#34;F&amp;#34;) } func main() { f() fmt.Println(&amp;#34;M&amp;#34;) }  A. F M D B. D F M C. F D M  🔑 答案解析：C
在线运行
defer 语句在返回之前就会被执行，所以输出顺序是 F D M。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_166</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_166/</link>
      <pubDate>Sun, 19 Jan 2025 19:27:29 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_166/</guid>
      <description>昨天只有3个G，如果把G的个数变为257个输出结果是怎么样
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync&amp;#34; ) func main() { runtime.GOMAXPROCS(1) var wg sync.WaitGroup wg.Add(257) for i := 1; i &amp;lt;= 257; i++ { go func(i int) { fmt.Println(i) wg.Done() }(i) } wg.Wait() } 🔑 答案解析：在线运行
257123...255256结果和 3个G的一致，应为本地 runq 长度上线是256 ，257G 添到P的时候 会进入 runnext区（弹夹上限256但是可以上膛一颗。因此最多257）
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_165</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_165/</link>
      <pubDate>Sat, 18 Jan 2025 19:27:10 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_165/</guid>
      <description>下方代码输出什么并解释一下
package main import ( &amp;#34;runtime&amp;#34; &amp;#34;sync&amp;#34; ) func main() { runtime.GOMAXPROCS(1) var wg sync.WaitGroup wg.Add(3) go func(n int) { println(n) wg.Done() }(1) go func(n int) { println(n) wg.Done() }(2) go func(n int) { println(n) wg.Done() }(3) wg.Wait() } 🔑 答案解析：在线运行
312浅谈： go函数会创建新的G，P里面有一个记录下一个运行的G 和一个本地队列（类似手枪上膛）。1G 2G 3G 依次进入P。最后就是下一个运行的G 是3G 队列里面是 1G、2G
深谈： runtime.GOMAXPROCS(1)的作用是限制P的数量为1 go 函数本质会调用 newproc ，newproc会调用newproc1 newproc1 会初始化新的G，然后调用runqput将G添加到P。P中有一个本地runq 和 runnext 。先进入runnext，第二个G来了先把第一个G从runnetx中挤到了本地runq。注意这个本地runq的长度为256。因此会先运行runnetx中3G，然后依次运行1G、2G .toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_164</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_164/</link>
      <pubDate>Fri, 17 Jan 2025 19:26:38 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_164/</guid>
      <description>下面这段代码能否通过编译，不能的话原因是什么；如果通过，输出什么。
package main import &amp;#34;fmt&amp;#34; func main() { list := new([]int) list = append(list, 1) fmt.Println(list) } 🔑 答案解析：在线运行
不能通过编译，new([]int) 之后的 list 是一个 *[]int 类型的指针，不能对指针执行 append 操作。可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_163</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_163/</link>
      <pubDate>Thu, 16 Jan 2025 13:09:00 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_163/</guid>
      <description>下面代码输出什么？
package main import &amp;#34;fmt&amp;#34; type A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { var a A = Work{3} s := a.(Work) fmt.Println(s.ShowA()) fmt.Println(s.ShowB()) }  A. 13 23 B. compilation error  🔑 答案解析：A 在线运行</description>
    </item>
    
    <item>
      <title>Go每日一题_162</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_162/</link>
      <pubDate>Wed, 15 Jan 2025 21:19:39 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_162/</guid>
      <description>下面代码输出什么？
package main import &amp;#34;fmt&amp;#34; func increaseA() int { var i int defer func() { i++ }() return i } func increaseB() (r int) { defer func() { r++ }() return r } func main() { fmt.Println(increaseA()) fmt.Println(increaseB()) }  A. 1 1 B. 0 1 C. 1 0 D. 0 0  🔑 答案解析：B 在线运行
 解析 increaseA() 的返回参数是匿名 increaseB() 是具名
在 Go 语言中，函数返回值的内存空间会分配到调用者的栈上。先运行return赋值后运行defer。
1. increaseA 的行为分析 func increaseA() int { var i int defer func() { i++ }() return i }  在 increaseA 的函数栈中，声明了一个局部变量 i，初始值为 0。 执行 return i 时，会将 i 的值（0）复制到调用者（main 函数）的栈上，作为返回值。 然后，defer 语句执行，将局部变量 i 的值从 0 增加到 1。 由于 defer 修改的是局部变量 i，而不是调用者栈上的返回值，因此返回值仍然是 0。  2.</description>
    </item>
    
    <item>
      <title>Go每日一题_161</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_161/</link>
      <pubDate>Tue, 14 Jan 2025 21:10:21 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_161/</guid>
      <description>下面代码中，x 已声明，y 没有声明，判断每条语句的对错。
1）x, _ := f() 2）x, _ = f() 3）x, y := f() 4）x, y = f() 🔑 答案解析：1）错 2）对 3）对 4）错
1. x, _ := f()  错误。 原因：:= 是短变量声明操作符，要求左侧的所有变量都必须是未声明的。由于 x 已经声明，因此不能使用 :=。 修正：如果 x 已经声明，应该使用 = 赋值操作符： x, _ = f()   2. x, _ = f()  正确。 原因：= 是赋值操作符，可以用于已声明的变量。x 已经声明，_ 是空白标识符，用于忽略返回值，因此这条语句是合法的。  3. x, y := f()  正确。 原因：:= 是短变量声明操作符，要求左侧至少有一个变量是未声明的。虽然 x 已经声明，但 y 是未声明的，因此这条语句是合法的。此时，x 会被重新赋值，y 会被声明并赋值。  4.</description>
    </item>
    
    <item>
      <title>Go每日一题_160</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_160/</link>
      <pubDate>Mon, 13 Jan 2025 12:22:18 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_160/</guid>
      <description>它们是否能编译通过？为什么？
// 32 位机器 1）var x int32 = 32. 2）var y int = x 3）var z rune = x 🔑 答案解析：1 可以 2 不可以 3 可以
解析 Go 语言类型系统与代码解析 1. 无类型字面量 在 Go 语言中，字面量（如 32.0）是无类型的（untyped）。无类型字面量可以根据上下文自动推断为目标类型。
示例 var a int64 = 32.0 // 32.0 是无类型浮点数字面量，赋值给 int64 类型 var b int = 32.0 // 32.0 是无类型浮点数字面量，赋值给 int 类型 var c float32 = 32.0 // 32.0 是无类型浮点数字面量，赋值给 float32 类型 var d complex64 = 32.</description>
    </item>
    
    <item>
      <title>Go每日一题_159</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_159/</link>
      <pubDate>Sun, 12 Jan 2025 15:25:17 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_159/</guid>
      <description>以下代码是否能正常运行，结果是？
package main func main() { v := new(int) *v = 2 println(5/+-*v) } 🔑 答案解析：可以正常运行 运行结果为 -2
在线运行
表达式解析 5/+-*v Go 语言的运算符优先级规则
 unary_op = &amp;ldquo;+&amp;rdquo; | &amp;ldquo;-&amp;rdquo; | &amp;ldquo;!&amp;rdquo; | &amp;ldquo;^&amp;rdquo; | &amp;ldquo;*&amp;rdquo; | &amp;ldquo;&amp;amp;&amp;rdquo; | &amp;ldquo;&amp;lt;-&amp;rdquo; .
 题中一元运算符(+、-、* ) +、- 和 * 同时也是算术运算符中的加、减和乘。
表达式: 5/+-*v。5 后面 /，很显然，这是除法。 而 + 前面没有操作数，因此是一个一元运算符；同理 - 和 * 也是一元运算符。而一元运算符有最高的优先级，因此这个表达式优先计算 +-*v 的值。
在规范中有这么一句话：
 对于整数操作数，一元运算符 + , - 和 ^ 有如下定义：（省略了 ^ 的解释） +x 是 0 + x -x 取其负值 是 0 - x</description>
    </item>
    
    <item>
      <title>Go每日一题_158</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_158/</link>
      <pubDate>Sat, 11 Jan 2025 23:04:42 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_158/</guid>
      <description>下面代码输出什么？
package main import &amp;#34;fmt&amp;#34; type A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { c := Work{3} var a A = c var b B = c fmt.Println(a.ShowB()) fmt.Println(b.ShowA()) }  A. 23 13 B.</description>
    </item>
    
    <item>
      <title>Go每日一题_157</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_157/</link>
      <pubDate>Fri, 10 Jan 2025 12:46:04 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_157/</guid>
      <description>下面代码中 A B 两处应该怎么修改才能顺利编译？
func main() { var m map[string]int //A 	m[&amp;#34;a&amp;#34;] = 1 if v := m[&amp;#34;b&amp;#34;]; v != nil { //B 	fmt.Println(v) } } 🔑 答案解析：// A
A 处只声明了map m ,并没有分配内存空间未初始化的map，写入会panic，
因此需要将 var m map[string]int 改为 m := make(map[string]int)
// B
key 为 b 的元素不存在的时候，v 会返回值类型对应的零值，类型为int因此v为0。类型int != nil 是不能通过编译的类型不匹配
因此需要v != nil 改为 v != 0
package main import ( &amp;#34;fmt&amp;#34; ) func main() { m := make(map[string]int) //A 	m[&amp;#34;a&amp;#34;] = 1 if v := m[&amp;#34;b&amp;#34;]; v !</description>
    </item>
    
    <item>
      <title>Go每日一题_156</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_156/</link>
      <pubDate>Thu, 09 Jan 2025 20:27:59 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_156/</guid>
      <description>切片 a、b、c 的长度和容量分别是多少？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { s := [3]int{1, 2, 3} a := s[:0] b := s[:2] c := s[1:2:cap(s)] fmt.Println(len(a), cap(a)) fmt.Println(len(b), cap(b)) fmt.Println(len(c), cap(c)) } 🔑 答案解析：a 长度和容量 0 3 b 长度和容量 2 3 c 长度和容量 1 2
在线运行
知识点：数组或切片的截取操作 截取操作有带 2 个或者 3 个参数，形如：[i:j] 和 [i:j:k]，
1. [i:j] 形式 [i:j] 是最常见的切片截取形式，表示从底层数组的第 i 个元素开始，到第 j 个元素（不包括第 j 个元素）结束。
 语法：s[i:j] 含义：  i：切片的起始索引（包含）。 j：切片的结束索引（不包含）。   长度：j - i 容量：从索引 i 开始，到底层数组的末尾。  如果底层数组的长度为 n，则容量为 n - i。    示例 s := [3]int{1, 2, 3} b := s[:2] // 从索引 0 开始，到索引 3（不包含）左闭右开 fmt.</description>
    </item>
    
    <item>
      <title>2264_字符串中最大的3位相同数字</title>
      <link>/posts/leetcode/data/2264_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%843%E4%BD%8D%E7%9B%B8%E5%90%8C%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 08 Jan 2025 14:00:23 +0800</pubDate>
      
      <guid>/posts/leetcode/data/2264_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%843%E4%BD%8D%E7%9B%B8%E5%90%8C%E6%95%B0%E5%AD%97/</guid>
      <description>力扣链接:2264. 字符串中最大的 3 位相同数字
 力扣难度 简单
算法评级: 2
难度分 1309
  题目：
给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ：
 该整数是 num 的一个长度为 3 的 子字符串 。 该整数由唯一一个数字重复 3 次组成。  以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 &amp;quot;&amp;quot; 。
注意：
 子字符串 是字符串中的一个连续字符序列。 num 或优质整数中可能存在 前导零 。  示例 1：
 输入：num = &amp;ldquo;6777133339&amp;rdquo;
输出：&amp;ldquo;777&amp;rdquo;
解释：num 中存在两个优质整数：&amp;ldquo;777&amp;rdquo; 和 &amp;ldquo;333&amp;rdquo; 。
&amp;ldquo;777&amp;rdquo; 是最大的那个，所以返回 &amp;ldquo;777&amp;rdquo; 。
 示例 2：
 输入：num = &amp;ldquo;2300019&amp;rdquo;
输出：&amp;ldquo;000&amp;rdquo;
解释：&amp;ldquo;000&amp;rdquo; 是唯一一个优质整数。</description>
    </item>
    
    <item>
      <title>Go每日一题_155</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_155/</link>
      <pubDate>Wed, 08 Jan 2025 13:03:00 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_155/</guid>
      <description>下面这段代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) type A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { c := Work{3} var a A = c var b B = c fmt.Println(a.ShowA()) fmt.Println(b.ShowB()) } 🔑 答案解析：1323在线运行</description>
    </item>
    
    <item>
      <title>3019_按键变更的次数</title>
      <link>/posts/leetcode/data/3019_%E6%8C%89%E9%94%AE%E5%8F%98%E6%9B%B4%E7%9A%84%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Tue, 07 Jan 2025 21:47:21 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3019_%E6%8C%89%E9%94%AE%E5%8F%98%E6%9B%B4%E7%9A%84%E6%AC%A1%E6%95%B0/</guid>
      <description>力扣链接:3019. 按键变更的次数
力扣难度 简单 算法评级: 2 知道常用数据结构和算法并简单使用 难度分 1176
 题目:
给你一个下标从 0 开始的字符串 s ，该字符串由用户输入。按键变更的定义是：使用与上次使用的按键不同的键。例如 s = &amp;ldquo;ab&amp;rdquo; 表示按键变更一次，而 s = &amp;ldquo;bBBb&amp;rdquo; 不存在按键变更。
返回用户输入过程中按键变更的次数。
注意：shift 或 caps lock 等修饰键不计入按键变更，也就是说，如果用户先输入字母 &amp;lsquo;a&amp;rsquo; 然后输入字母 &amp;lsquo;A&amp;rsquo; ，不算作按键变更。
示例 1：
 输入：s = &amp;ldquo;aAbBcC&amp;rdquo;
输出：2
解释：
从 s[0] = &amp;lsquo;a&amp;rsquo; 到 s[1] = &amp;lsquo;A&amp;rsquo;，不存在按键变更，因为不计入 caps lock 或 shift 。
从 s[1] = &amp;lsquo;A&amp;rsquo; 到 s[2] = &amp;lsquo;b&amp;rsquo;，按键变更。
从 s[2] = &amp;lsquo;b&amp;rsquo; 到 s[3] = &amp;lsquo;B&amp;rsquo;，不存在按键变更，因为不计入 caps lock 或 shift 。</description>
    </item>
    
    <item>
      <title>Go每日一题_154</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_154/</link>
      <pubDate>Tue, 07 Jan 2025 11:47:02 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_154/</guid>
      <description>下面这段代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { i := 65 fmt.Println(string(i)) }  A. A B. 65 C. compilation error  🔑 答案解析：A 在线运行
string(i),在 Go 语言中，string(int) 会将整数解释为 Unicode 码点，并返回对应的字符。
65 是字符 &amp;lsquo;A&amp;rsquo; 的 ASCII 码（也是 Unicode 码点），因此 string(65) 的结果是字符串 &amp;ldquo;A&amp;rdquo;。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_153</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_153/</link>
      <pubDate>Mon, 06 Jan 2025 12:10:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_153/</guid>
      <description>下面代码填空cc处可以填入哪个选项？ 且描述一下填入后运行的结果
package main import &amp;#34;fmt&amp;#34; func main() { var s1 []int var s2 = []int{} _, _ = s1, s2 if 填空 == nil { fmt.Println(&amp;#34;yes nil&amp;#34;) } else { fmt.Println(&amp;#34;no nil&amp;#34;) } }  A. s1 B. s2 C. s1、s2 都可以 D. 以上都不可以  🔑 答案解析：C 在线运行
package main import &amp;#34;fmt&amp;#34; func main() { var s1 []int var s2 = []int{} _, _ = s1, s2 if s1 == nil { fmt.</description>
    </item>
    
    <item>
      <title>Go每日一题_152</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_152/</link>
      <pubDate>Sun, 05 Jan 2025 18:03:19 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_152/</guid>
      <description>以下代码输出什么？
package main func main() { var x = []int{4: 44, 55, 66, 1: 77, 88} println(len(x), x[2]) }  A：5 66 B：5 88 C：7 88 D：以上都不对  🔑 答案解析：C 在线运行
Go中切片\数组初始化是可以携带索引的。
// 1. 不带键的元素 slice1 := []int{1, 2, 3} // 2. 带键的元素（键是索引） slice2 := []string{0: &amp;#34;a&amp;#34;, 1: &amp;#34;b&amp;#34;, 2: &amp;#34;c&amp;#34;} 本题中是一种带有显式索引和隐式索引的混合初始化方式。
解析 []int{4: 44, 55, 66, 1: 77, 88} 的初始化过程：  4: 44,显式指定索引下标 4 处的值为 44。 [0, 0, 0, 0, 44] 55 和 66 ,未指定索引,则从上一个索引位置开始依次放置。</description>
    </item>
    
    <item>
      <title>Go每日一题_151</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_151/</link>
      <pubDate>Sat, 04 Jan 2025 17:03:14 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_151/</guid>
      <description>以下代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { a := []int{2: 1} fmt.Println(a) }  A：编译错误； B：[2 1]； C：[0 0 1]； D：[0 1]  🔑 答案解析：C 在线运行
Go中切片\数组初始化是可以携带索引的。
// 1. 不带键的元素 slice1 := []int{1, 2, 3} // 2. 带键的元素（键是索引） slice2 := []string{0: &amp;#34;a&amp;#34;, 1: &amp;#34;b&amp;#34;, 2: &amp;#34;c&amp;#34;} 本题中含义为 索引下标2的元素为1 ，因此切片内容为[0 0 1]
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_150</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_150/</link>
      <pubDate>Fri, 03 Jan 2025 13:55:19 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_150/</guid>
      <description>以下代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch1 := make(chan int) go fmt.Println(&amp;lt;-ch1) ch1 &amp;lt;- 5 time.Sleep(1 * time.Second) }  A：5 B：不能编译 C：运行时死锁  🔑 答案解析：C 在线运行
 fatal error: all goroutines are asleep - deadlock!
 官方对Go语句的描述
 go 语句用于启动一个新的 Goroutine（并发执行的线程），并在其中执行一个函数调用。
 The function value and parameters are evaluated as usual in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete.</description>
    </item>
    
    <item>
      <title>Go每日一题_149</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_149/</link>
      <pubDate>Thu, 02 Jan 2025 00:17:12 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_149/</guid>
      <description>对 add() 函数调用正确的是？
func add(args ...int) int { sum := 0 for _, arg := range args { sum += arg } return sum }  A. add(1, 2) B. add(1, 3, 7) C. add([]int{1, 2}) D. add([]int{1, 3, 7}&amp;hellip;)  🔑 答案解析：A B D 在线运行
Go官方文档-Passing_arguments_to_&amp;hellip;_parameters
add 是一个可变参数函数，接受任意数量的 int 类型参数。
参数 args 的类型是 &amp;hellip;int，在函数内部表现为 []int（即一个 int 类型的切片）。
虽然 []int 和 &amp;hellip;int 在底层都是切片，但 Go 语言的类型系统要求显式地将切片展开为可变参数。
.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_148</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_148/</link>
      <pubDate>Wed, 01 Jan 2025 13:08:46 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_148/</guid>
      <description>下列选项正确的是？
package main import &amp;#34;fmt&amp;#34; func main() { str := &amp;#34;hello&amp;#34; str[0] = &amp;#39;x&amp;#39; fmt.Println(str) }  A. hello B. xello C. compilation error  🔑 答案解析：C
在线运行
Go官方文档-String_types
 Strings are immutable: once created, it is impossible to change the contents of a string.
字符串是不可变的：一旦创建，就无法改变字符串的内容。
 题目中str是string,无法改变字符串的内容,因此str[0] = &amp;lsquo;x&amp;rsquo;会报错。
扩展 string的内部结构 string在Go中的内部结构是reflect.StringHeader位于reflect/value.go
type StringHeader struct { Data uintptr Len int }  Data 是一个 uintptr 类型，表示指向字符串数据（字节数组）的指针。 Len 是一个 int 类型，表示字符串的长度。  而Data字符串字面量：其数据存储在内存的只读的data段（数据区）。</description>
    </item>
    
    <item>
      <title>Go每日一题_147</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_147/</link>
      <pubDate>Mon, 30 Dec 2024 20:54:49 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_147/</guid>
      <description>下面这段代码输出什么?
package main import ( &amp;#34;fmt&amp;#34; ) func hello(i int) { fmt.Println(i) } func main() { i := 5 defer hello(i) i = i + 10 } 🔑 答案解析：5 在线运行 Go传递只有值传递 运行到defer hello(i)的时候就已经确定i的值了
下方是defer的结构
type _defer struct { heap bool rangefunc bool // true for rangefunc list 	sp uintptr // sp at time of defer 	pc uintptr // pc at time of defer 	fn func() // can be nil for open-coded defers 	link *_defer // next defer on G; can point to either heap or stack!</description>
    </item>
    
    <item>
      <title>Go每日一题_146</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_146/</link>
      <pubDate>Sun, 29 Dec 2024 12:51:57 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_146/</guid>
      <description>以下代码输出什么？
package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { t := struct { time.Time N int }{ time.Date(2020, 12, 20, 0, 0, 0, 0, time.UTC), 5, } m, _ := json.Marshal(t) fmt.Printf(&amp;#34;%s&amp;#34;, m) }  A：{&amp;ldquo;Time&amp;rdquo;: &amp;ldquo;2020-12-20T00:00:00Z&amp;rdquo;, &amp;ldquo;N&amp;rdquo;: 5 }； B：&amp;ldquo;2020-12-20T00:00:00Z&amp;rdquo;； C：{&amp;ldquo;N&amp;rdquo;: 5}； D：&amp;lt;nil&amp;gt;  🔑 答案解析：B 在线运行
Go 结构体内嵌与继承方法 在 Go 语言中，结构体可以内嵌匿名结构体，从而实现类似继承的效果。例如，下面的结构体内嵌了匿名结构体 time.Time：
struct { time.Time N int } 这种内嵌匿名结构体的方式使得外部结构体继承了 time.Time 的方法集。具体来说，由于 time.Time 实现了 json.Marshaler 接口：</description>
    </item>
    
    <item>
      <title>3083_字符串及其反转中是否存在同一子字符串</title>
      <link>/posts/leetcode/data/3083_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E5%8F%8D%E8%BD%AC%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%90%8C%E4%B8%80%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 28 Dec 2024 18:04:37 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3083_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E5%85%B6%E5%8F%8D%E8%BD%AC%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%90%8C%E4%B8%80%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>力扣链接:3083. 字符串及其反转中是否存在同一子字符串
 力扣难度 简单
算法评级: 2 知道常用数据结构和算法并简单使用
难度分 1173
  题目：
给你一个字符串 s ，请你判断字符串 s 是否存在一个长度为 2 的子字符串，在其反转后的字符串中也出现。
如果存在这样的子字符串，返回 true；如果不存在，返回 false 。
示例 1：
 输入：s = &amp;ldquo;leetcode&amp;rdquo;
输出：true
解释：子字符串 &amp;ldquo;ee&amp;rdquo; 的长度为 2，它也出现在 reverse(s) == &amp;ldquo;edocteel&amp;rdquo; 中。
 示例 2：
 输入：s = &amp;ldquo;abcba&amp;rdquo;
输出：true
解释：所有长度为 2 的子字符串 &amp;ldquo;ab&amp;rdquo;、&amp;ldquo;bc&amp;rdquo;、&amp;ldquo;cb&amp;rdquo;、&amp;ldquo;ba&amp;rdquo; 也都出现在 reverse(s) == &amp;ldquo;abcba&amp;rdquo; 中。
 示例 3：
 输入：s = &amp;ldquo;abcd&amp;rdquo;
输出：false
解释：字符串 s 中不存在满足「在其反转后的字符串中也出现」且长度为 2 的子字符串。
  func isSubstringPresent(s string) bool { }  🔑 答案解析： 👈点击// isSubstringPresent 函数用于判断给定字符串 s 中是否存在一对字符的子串， // 这对字符以相反的顺序也出现过。 func isSubstringPresent(s string) bool { // 创建一个 26×26 的布尔数组 vis，用于记录每对字符是否出现过。  // 索引的含义是：vis[x][y] 表示字符 x 和字符 y 组成的子串是否出现过。  // 这里的 x 和 y 是字符在字母表中的索引，从 0 到 25 分别对应 &amp;#39;a&amp;#39; 到 &amp;#39;z&amp;#39;。  vis := [26][26]bool{} // 遍历字符串 s，从第二个字符开始，因为要检查相邻的两个字符组成的子串。  for i := 1; i &amp;lt; len(s); i++ { // 计算当前字符对中第一个字符在字母表中的索引。  // 例如，如果字符是 &amp;#39;a&amp;#39;，则 x 为 0；如果是 &amp;#39;b&amp;#39;，则 x 为 1，以此类推。  x := s[i-1] - &amp;#39;a&amp;#39; // 计算当前字符对中第二个字符在字母表中的索引。  y := s[i] - &amp;#39;a&amp;#39; // 将当前字符对标记为已出现过。  vis[x][y] = true // 检查是否存在相反顺序的字符对。  // 如果 vis[y][x] 为 true，说明字符 y 和字符 x 组成的子串也出现过，  // 即找到了满足条件的子串，返回 true。  if vis[y][x] { return true } } // 如果遍历完整个字符串都没有找到满足条件的子串，返回 false。  return false } .</description>
    </item>
    
    <item>
      <title>3159_查询数组中元素的出现位置</title>
      <link>/posts/leetcode/data/3159_%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Sat, 28 Dec 2024 14:28:22 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3159_%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE/</guid>
      <description>力扣链接:3159. 查询数组中元素的出现位置
 力扣难度 中等
算法评级: 2 知道常用数据结构和算法并简单使用
难度分 1263
  题目： 给你一个整数数组 nums ，一个整数数组 queries 和一个整数 x 。
对于每个查询 queries[i] ，你需要找到 nums 中第 queries[i] 个 x 的位置，并返回它的下标。如果数组中 x 的出现次数少于 queries[i] ，该查询的答案为 -1 。
请你返回一个整数数组 answer ，包含所有查询的答案。
示例 1：
 输入：nums = [1,3,1,7], queries = [1,3,2,4], x = 1
输出：[0,-1,2,-1]
解释：
 第 1 个查询，第一个 1 出现在下标 0 处。 第 2 个查询，nums 中只有两个 1 ，所以答案为 -1 。 第 3 个查询，第二个 1 出现在下标 2 处。 第 4 个查询，nums 中只有两个 1 ，所以答案为 -1 。   示例 2：</description>
    </item>
    
    <item>
      <title>3046_分割数组</title>
      <link>/posts/leetcode/data/3046_%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 28 Dec 2024 13:02:42 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3046_%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/</guid>
      <description>力扣链接:3046. 分割数组
 力扣难度 简单
算法评级: 2 知道常用数据结构和算法并简单使用
难度分 1212
  题目： 给你一个长度为 偶数 的整数数组 nums 。你需要将这个数组分割成 nums1 和 nums2 两部分，要求：
 nums1.length == nums2.length == nums.length / 2 。 nums1 应包含 互不相同 的元素。 nums2也应包含 互不相同 的元素。  如果能够分割数组就返回 true ，否则返回 false 。
示例 1：
 输入：nums = [1,1,2,2,3,4]
输出：true
解释：分割 nums 的可行方案之一是 nums1 = [1,2,3] 和 nums2 = [1,2,4] 。
 示例 2：
 输入：nums = [1,1,1,1]
输出：false</description>
    </item>
    
    <item>
      <title>Go每日一题_145</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_145/</link>
      <pubDate>Sat, 28 Dec 2024 12:34:35 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_145/</guid>
      <description>定义一个包内全局字符串变量，下面语法正确的是（多选）：
 A. var str string B. str := &amp;quot;&amp;quot; C. str = &amp;quot;&amp;quot; D. var str = &amp;quot;&amp;quot;  🔑 答案解析：A D
只有 用var来定义才能在全局定义
B 只支持局部变量声明 C 赋值,不是定义
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_144</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_144/</link>
      <pubDate>Fri, 27 Dec 2024 23:14:28 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_144/</guid>
      <description>下面这段代码输出什么？
type People struct{} func (p *People) ShowA() { fmt.Println(&amp;#34;showA&amp;#34;) p.ShowB() } func (p *People) ShowB() { fmt.Println(&amp;#34;showB&amp;#34;) } type Teacher struct { People } func (t *Teacher) ShowB() { fmt.Println(&amp;#34;teacher showB&amp;#34;) } func main() { t := Teacher{} t.ShowB() } 🔑 答案解析：teacher showB在线运行
知识点：结构体嵌套 Teacher struct 内嵌套了People struct 在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。
如果想要调用People的ShowB() 方法需要使用
t.People.ShowB() 在线运行
t.People.ShowA() 等价 t.ShowA() 因为Teacher没有ShowA()方法，因此可以省略。这是Go提供的语法糖
// 二者等价 t.People.ShowA() t.ShowA() 在线运行
.</description>
    </item>
    
    <item>
      <title>Go每日一题_143</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_143/</link>
      <pubDate>Thu, 26 Dec 2024 20:28:59 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_143/</guid>
      <description>下面这段代码输出什么？
package main import &amp;#34;fmt&amp;#34; func main() { i := -5 j := +5 fmt.Printf(&amp;#34;%+d %+d&amp;#34;, i, j) }  A. -5 +5 B. +5 +5 C. -5 5 D. +5 -5  🔑 答案解析：A 在线运行
根据官方文档:https://pkg.go.dev/fmt
%b 二进制%c 对应 Unicode 码位所表示的字符%d 十进制%o 八进制%O 带 0o 前缀的八进制%q 使用 Go 语法安全转义的单引号括起来的字符字面量%x 十六进制，a - f 用小写字母%X 十六进制，A - F 用大写字母%U Unicode 格式：U+1234；等同于 &amp;quot;U+%04X&amp;quot;+：始终为数值打印符号；对于 %q（%+q），保证仅输出 ASCII 字符。-：在右侧而非左侧填充空格（使字段左对齐）。#：备用格式：二进制（%#b）添加前导 0b，八进制（%#o）添加前导 0，十六进制（%#x 或 %#X）添加前导 0x 或 0X；对于 %p（%#p），不显示前导 0x；对于 %q，如果 [strconv.</description>
    </item>
    
    <item>
      <title>3285_找到稳定山的下标</title>
      <link>/posts/leetcode/data/3285_%E6%89%BE%E5%88%B0%E7%A8%B3%E5%AE%9A%E5%B1%B1%E7%9A%84%E4%B8%8B%E6%A0%87/</link>
      <pubDate>Wed, 25 Dec 2024 15:05:58 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3285_%E6%89%BE%E5%88%B0%E7%A8%B3%E5%AE%9A%E5%B1%B1%E7%9A%84%E4%B8%8B%E6%A0%87/</guid>
      <description>力扣链接:3285. 找到稳定山的下标
 力扣难度 简单
算法评级: 1 无算法要求
难度分 1166
  有 n 座山排成一列，每座山都有一个高度。给你一个整数数组 height ，其中 height[i] 表示第 i 座山的高度，再给你一个整数 threshold 。
对于下标不为 0 的一座山，如果它左侧相邻的山的高度 严格大于 threshold ，那么我们称它是 稳定 的。我们定义下标为 0 的山 不是 稳定的。
请你返回一个数组，包含所有 稳定 山的下标，你可以以 任意 顺序返回下标数组。
 示例 1：
 输入：height = [1,2,3,4,5], threshold = 2
输出：[3,4]
解释：
下标为 3 的山是稳定的，因为 height[2] == 3 大于 threshold == 2 。 下标为 4 的山是稳定的，因为 height[3] == 4 大于 threshold == 2.</description>
    </item>
    
    <item>
      <title>Go每日一题_142</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_142/</link>
      <pubDate>Wed, 25 Dec 2024 00:24:33 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_142/</guid>
      <description>date: &amp;lsquo;2024-12-25T00:09:11+08:00&amp;rsquo; draft: false title: &amp;lsquo;Go每日一题_141&amp;rsquo; 下面这段代码输出什么？
package main import &amp;#34;fmt&amp;#34; func main() { var s map[string]int delete(s, &amp;#34;h&amp;#34;) fmt.Println(s[&amp;#34;h&amp;#34;]) }  A. runtime panic B. 0 C. compilation error  🔑 答案解析：B 在线运行
 对未初始化make的map使用delete是不会报错的 访问未初始化,返回值类型对应的零值  扩展 对未初始化的map赋值会panic
package main import &amp;#34;fmt&amp;#34; func main() { var s map[string]int s[&amp;#34;h&amp;#34;] = 1 // panic: assignment to entry in nil map 	fmt.Println(s[&amp;#34;h&amp;#34;]) } 在线运行
 这种错误是可避免的语法错误,建议使用单元测试试着跑一下代码流程
 .</description>
    </item>
    
    <item>
      <title>Go每日一题_141</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_141/</link>
      <pubDate>Wed, 25 Dec 2024 00:09:11 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_141/</guid>
      <description>下面这段代码输出什么？
package main import &amp;#34;fmt&amp;#34; func main() { s := make(map[string]int) delete(s, &amp;#34;h&amp;#34;) fmt.Println(s[&amp;#34;h&amp;#34;]) }  A. runtime panic B. 0 C. compilation error  🔑 答案解析：B 在线运行 delete不存在的Key 并不会panic
扩展问题 本题中s是已经初始化的，如果未初始化结构还是一样的吗？
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_140</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_140/</link>
      <pubDate>Tue, 24 Dec 2024 23:28:20 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_140/</guid>
      <description>下面这段代码输出什么？
package main import &amp;#34;fmt&amp;#34; func main() { var i interface{} if i == nil { fmt.Println(&amp;#34;nil&amp;#34;) return } fmt.Println(&amp;#34;not nil&amp;#34;) }  A. nil B. not nil C. compilation error 🔑 答案解析：A 在线运行
简单来说,接口变量有2个值,一个是类型,另一个是值。 if 接口 时,值和类型都为零值时,接口live() == nil 判断才为T
接口interface内部结构 interface共有2种表现形式
// 1 空接口 var MyInterface interface{} // 2 非空接口 type MyInterface interface { function() } 对应的2种底层结构
 空接口  type eface struct { // 空接口  _type *_type // 类型信息  data unsafe.</description>
    </item>
    
    <item>
      <title>Go每日一题_139</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_139/</link>
      <pubDate>Mon, 23 Dec 2024 17:01:49 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_139/</guid>
      <description>以下哪种类型可以使用 cap() 函数？
 A. array B. slice C. map D. channel  🔑 答案解析：ABD 官方文档
func cap(v Type) int// cap 内建函数根据 v 的类型返回 v 的容量：  数组 array：v 中元素的数量（与 len(v) 相同）。 数组指针 *array：*v 中元素的数量（与 len(v) 相同）。 切片 slice：切片重新切割时可以达到的最大长度； 通道 channel：通道的缓冲区容量，以元素为单位； 如果 v 为 nil，则 cap(v) 为零。   .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>1387_将整数按权重排序</title>
      <link>/posts/leetcode/data/1387_%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 22 Dec 2024 15:09:23 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1387_%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F/</guid>
      <description>力扣链接:1387. 将整数按权重排序
 力扣难度 中等
算法评级: 6 深入理解并灵活应用数据结构和算法，理解高级数据结构
难度分 1507
  题目：
我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：
 如果 x 是偶数，那么 x = x / 2 如果 x 是奇数，那么 x = 3 * x + 1  比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 &amp;ndash;&amp;gt; 10 &amp;ndash;&amp;gt; 5 &amp;ndash;&amp;gt; 16 &amp;ndash;&amp;gt; 8 &amp;ndash;&amp;gt; 4 &amp;ndash;&amp;gt; 2 &amp;ndash;&amp;gt; 1）。
给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。</description>
    </item>
    
    <item>
      <title>Go每日一题_138</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_138/</link>
      <pubDate>Sun, 22 Dec 2024 12:52:47 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_138/</guid>
      <description>下面这段代码输出什么？
func main() { a := [2]int{5, 6} b := [3]int{5, 6} if a == b { fmt.Println(&amp;#34;equal&amp;#34;) } else { fmt.Println(&amp;#34;not equal&amp;#34;) } }  A. compilation error B. equal C. not equal  🔑 答案解析：在线运行 A [2]int 和 [3]int 在Go中是不同的类型 不能通过 == 运算符对比
 ./prog.go:8:10: invalid operation: a == b (mismatched types [2]int and [3]int)
 .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>2545_根据第K场考试的分数排序</title>
      <link>/posts/leetcode/data/2545_%E6%A0%B9%E6%8D%AE%E7%AC%ACk%E5%9C%BA%E8%80%83%E8%AF%95%E7%9A%84%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 21 Dec 2024 13:47:52 +0800</pubDate>
      
      <guid>/posts/leetcode/data/2545_%E6%A0%B9%E6%8D%AE%E7%AC%ACk%E5%9C%BA%E8%80%83%E8%AF%95%E7%9A%84%E5%88%86%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>力扣链接:2545. 根据第 K 场考试的分数排序
 力扣难度 中等
算法评级: 3 理解常用数据结构和算法
难度分 1294
  题目：
班里有 m 位学生，共计划组织 n 场考试。给你一个下标从 0 开始、大小为 m x n 的整数矩阵 score ，其中每一行对应一位学生，而 score[i][j] 表示第 i 位学生在第 j 场考试取得的分数。矩阵 score 包含的整数 互不相同 。
另给你一个整数 k 。请你按第 k 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。
返回排序后的矩阵。
示例 1：  输入：score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2 输出：[[7,5,11,2],[10,6,9,1],[4,8,3,15]]
解释：在上图中，S 表示学生，E 表示考试。
 下标为 1 的学生在第 2 场考试取得的分数为 11 ，这是考试的最高分，所以 TA 需要排在第一。 下标为 0 的学生在第 2 场考试取得的分数为 9 ，这是考试的第二高分，所以 TA 需要排在第二。 下标为 2 的学生在第 2 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第三。   示例 2：  输入：score = [[3,4],[5,6]], k = 0 输出：[[5,6],[3,4]] 解释：在上图中，S 表示学生，E 表示考试。</description>
    </item>
    
    <item>
      <title>Go每日一题_137</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_137/</link>
      <pubDate>Sat, 21 Dec 2024 01:24:56 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_137/</guid>
      <description>下面这段代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { a := [5]int{1, 2, 3, 4, 5} t := a[3:4:4] fmt.Println(t[0]) }  A.3 B.4 C.compilation error  🔑 答案解析：B 在线运行
a 为 长度为 5的数组 元素为 1, 2, 3, 4, 5
t := baseStr[low:high:max] low指定开始元素下标，high指定结束元素下标，max指定切片能增长到的元素下标
a[3:4:4] 的意思是 下标为3开始 到下标4结束 左闭右开 最大为到4下标 因此 t的内容为 4
a[3:4:4] // 4 a[3:4:5] // 4 a[3:4:6] // 错误 a 下标最大为4 开区间 所以能为最大为5 a[3:5:5] // [4 5]</description>
    </item>
    
    <item>
      <title>3138_同位字符串连接的最小长度</title>
      <link>/posts/leetcode/data/3138_%E5%90%8C%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Fri, 20 Dec 2024 23:57:43 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3138_%E5%90%8C%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6/</guid>
      <description>力扣链接:3138. 同位字符串连接的最小长度
 力扣难度 中等
算法评级: 5 熟练掌握常用数据结构和算法，初步了解高级数据结构 难度分 1979
  题目:
给你一个字符串 s ，它由某个字符串 t 和若干 t 的 同位字符串 连接而成。
请你返回字符串 t 的 最小 可能长度。
同位字符串 指的是重新排列一个单词得到的另外一个字符串，原来字符串中的每个字符在新字符串中都恰好只使用一次。
示例 1：
 输入：s = &amp;ldquo;abba&amp;rdquo;
输出：2
解释：
一个可能的字符串 t 为 &amp;ldquo;ba&amp;rdquo; 。
 示例 2：
 输入：s = &amp;ldquo;cdef&amp;rdquo;
输出：4
解释：
一个可能的字符串 t 为 &amp;ldquo;cdef&amp;rdquo; ，注意 t 可能等于 s 。
 提示：
 1 &amp;lt;= s.length &amp;lt;= 105 s 只包含小写英文字母。   func minAnagramLength(s string) int { }  🧠思路: 👈点击枚举 设 s字符串的长度为n,阅读题目可得提供的s一定是由 字符串 t构成的。(有确定的结)</description>
    </item>
    
    <item>
      <title>Go每日一题_136</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_136/</link>
      <pubDate>Fri, 20 Dec 2024 22:34:36 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_136/</guid>
      <description>以下代码能否通过编译？
package main import ( &amp;#34;fmt&amp;#34; ) type worker interface { work() } type person struct { name string worker } func main() { var w worker = person{} fmt.Println(w) }  A: 能； B: 不能； C: 不知道  🔑 答案解析：答: A 在线运行
01 我们都知晓 Go 没有继承，但可以通过内嵌类型模拟部分继承的功能。大家要记住，接口也是类型，自然也将它作为嵌入类型。如果题目的 person 接口体改为：
type person struct { name string worker worker } 相信会有更多人答对，这和嵌入类型唯一的区别在于是否显示指定了字段名，其他并无区别。
将接口作为嵌入类型可能让人感觉有些奇怪：那这个类型不是默认就实现了这个接口？！确实是这样的，所以才有了题目中这一句能编译通过：
var w worker = person{} 只不过，因为实例化 person 时，没有给 worker 指定值，因此 person 中的 worker 是 nil，调用它的话会报错，但编译是没问题的。</description>
    </item>
    
    <item>
      <title>Go: GPM的数量限制</title>
      <link>/posts/skill/data/go_gpm%E7%9A%84%E6%95%B0%E9%87%8F%E9%99%90%E5%88%B6/</link>
      <pubDate>Wed, 18 Dec 2024 14:16:42 +0800</pubDate>
      
      <guid>/posts/skill/data/go_gpm%E7%9A%84%E6%95%B0%E9%87%8F%E9%99%90%E5%88%B6/</guid>
      <description>G 协程的抽象
Goroutine (go /ruːˈtiːn/ 谐音 Go 如 听) 经 Golang 优化后的特殊“协程”
限制 语言上无任何的限制,但是理论上会受到机器的内存限制,每个G创建时会占用4KB左右的内存空间
注：Goroutine 创建所需申请的 2-4KB 是需要连续的内存块。
M 系统线程的抽象
在 Go 的并发模型中，G（Goroutine）是一个轻量级的执行单元，它需要通过系统线程（M）来执行。 每个 G 都会被映射到一个可用的 M 上，M 是操作系统层面的线程，负责实际的 CPU 执行。
限制 M 是可以通过runtime下的 debug包SetMaxThreads函数去设置的。默认值为10,000 个线程 官方文档
 SetMaxThreads 设置 Go 程序可以使用的操作系统线程的最大数量。如果程序尝试使用超过这个数量的线程，程序将崩溃。SetMaxThreads 返回之前的设置值。初始设置为 10,000 个线程。 ? 这个限制控制的是操作系统线程的数量，而不是 goroutine 的数量。只有当 goroutine 准备运行，但所有现有的线程都因系统调用、cgo 调用被阻塞，或者由于使用了 runtime.LockOSThread 被锁定给其他 goroutine 时，Go 程序才会创建一个新的线程。
SetMaxThreads 主要用于限制那些创建无限数量线程的程序的影响。其目的是在程序把操作系统拖垮之前先把程序本身终止掉。
 P p即 processor，是 golang 中的调度器；
p 是 gmp 的中枢，借由 p 承上启下，实现 g 和 m 之间的动态有机结合；</description>
    </item>
    
    <item>
      <title>Go每日一题_135</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_135/</link>
      <pubDate>Wed, 18 Dec 2024 12:24:37 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_135/</guid>
      <description>下面这段代码输出什么？
package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; ) type AutoGenerated struct { Age int `json:&amp;#34;age&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Child []int `json:&amp;#34;child&amp;#34;` } func main() { jsonStr1 := `{&amp;#34;age&amp;#34;: 14,&amp;#34;name&amp;#34;: &amp;#34;potter&amp;#34;, &amp;#34;child&amp;#34;:[1,2,3]}` a := AutoGenerated{} json.Unmarshal([]byte(jsonStr1), &amp;amp;a) aa := a.Child fmt.Println(aa) jsonStr2 := `{&amp;#34;age&amp;#34;: 12,&amp;#34;name&amp;#34;: &amp;#34;potter&amp;#34;, &amp;#34;child&amp;#34;:[3,4,5,7,8,9]}` json.Unmarshal([]byte(jsonStr2), &amp;amp;a) fmt.Println(aa) }  A：[1 2 3] [1 2 3] ； B：[1 2 3] [3 4 5]； C：[1 2 3] [3 4 5 6 7 8 9]； D：[1 2 3] [3 4 5 0 0 0]  🔑 答案解析：答: B 在线运行</description>
    </item>
    
    <item>
      <title>3291_形成目标字符串需要的最少字符串数_I</title>
      <link>/posts/leetcode/data/3291_%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0_i/</link>
      <pubDate>Tue, 17 Dec 2024 14:34:51 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3291_%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0_i/</guid>
      <description>力扣链接:3291. 形成目标字符串需要的最少字符串数 I
 力扣难度 中等
算法评级: 6 深入理解并灵活应用数据结构和算法，理解高级数据结构
难度分 2082
  题目: 给你一个字符串数组 words 和一个字符串 target。
如果字符串 x 是 words 中 任意 字符串的 前缀 ，则认为 x 是一个 有效 字符串。
现计划通过 连接 有效字符串形成 target ，请你计算并返回需要连接的 最少 字符串数量。如果无法通过这种方式形成 target，则返回 -1。
示例 1：
 输入： words = [&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;aaaaa&amp;rdquo;,&amp;ldquo;bcdef&amp;rdquo;], target = &amp;ldquo;aabcdabc&amp;rdquo;
输出： 3
解释：
target 字符串可以通过连接以下有效字符串形成：
 words[1] 的长度为 2 的前缀，即 &amp;ldquo;aa&amp;rdquo;。 words[2] 的长度为 3 的前缀，即 &amp;ldquo;bcd&amp;rdquo;。 words[0] 的长度为 3 的前缀，即 &amp;ldquo;abc&amp;rdquo;。   示例 2：</description>
    </item>
    
    <item>
      <title>Go每日一题_134</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_134/</link>
      <pubDate>Tue, 17 Dec 2024 14:00:22 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_134/</guid>
      <description>下面这段代码输出什么？
func main() { a := 5 b := 8.1 fmt.Println(a + b) }  A.13.1 B.13 C.compilation error  🔑 答案解析：答 C 在线运行:https://go.dev/play/p/VDTgpXoukTb
在Go中，变量之间没有隐式类型转换。但是，编译器可以进行变量和常量之间的隐式类型转换
题目中 a为 int变量 b为 float64变量\
不同类型不能使用 + 运算符
常量之间的隐式类型转换
func main() { const a = 5 const b = 8.1 fmt.Println(a + b) // 13.1 } 在线运行 ：https://go.dev/play/p/4KXch9jes-y
类型的优先级为： 整数(int)&amp;lt;符文数(rune)&amp;lt;浮点数(float)&amp;lt;复数(Imag)
func main() { a := 5 const b = 8.1 fmt.Println(a + b) // 报错 } 在线运行：https://go.</description>
    </item>
    
    <item>
      <title>Go: Map 是并发安全的吗？</title>
      <link>/posts/skill/data/go_map%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97/</link>
      <pubDate>Mon, 16 Dec 2024 20:06:16 +0800</pubDate>
      
      <guid>/posts/skill/data/go_map%E6%98%AF%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97/</guid>
      <description>结论 并发读安全，并发写不安全
原因 // map(集合)底层结构 type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go. 	// Make sure this stays in sync with the compiler&amp;#39;s definition. 	count int // # live cells == size of map. Must be first (used by len() builtin) 	flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) 	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details 	hash0 uint32 // hash seed  buckets unsafe.</description>
    </item>
    
    <item>
      <title>Go: 为什么Map是无序的</title>
      <link>/posts/skill/data/go_%E4%B8%BA%E4%BB%80%E4%B9%88map%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84/</link>
      <pubDate>Mon, 16 Dec 2024 19:47:30 +0800</pubDate>
      
      <guid>/posts/skill/data/go_%E4%B8%BA%E4%BB%80%E4%B9%88map%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84/</guid>
      <description>底层结构 // map(集合) type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go. 	// Make sure this stays in sync with the compiler&amp;#39;s definition. 	count int // # live cells == size of map. Must be first (used by len() builtin) 	flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) 	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details 	hash0 uint32 // hash seed  buckets unsafe.</description>
    </item>
    
    <item>
      <title>Go: slice(切片) 和 map(集合) 未初始化操作会怎样</title>
      <link>/posts/skill/data/go_map_slice%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E4%BC%9A%E6%80%8E%E6%A0%B7/</link>
      <pubDate>Mon, 16 Dec 2024 19:03:04 +0800</pubDate>
      
      <guid>/posts/skill/data/go_map_slice%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E4%BC%9A%E6%80%8E%E6%A0%B7/</guid>
      <description>底层结构 // slice(切片) type SliceHeader struct { Data uintptr // 底层数组的地址 	Len int // 长度 	Cap int // 容量 } // map(集合) type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go. 	// Make sure this stays in sync with the compiler&amp;#39;s definition. 	count int // # live cells == size of map. Must be first (used by len() builtin) 	flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) 	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details 	hash0 uint32 // hash seed  buckets unsafe.</description>
    </item>
    
    <item>
      <title>Go: slice(切片) 和array(数组) 的区别</title>
      <link>/posts/skill/data/go_slice%E5%92%8Carray%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 16 Dec 2024 16:10:18 +0800</pubDate>
      
      <guid>/posts/skill/data/go_slice%E5%92%8Carray%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>底层结构 array(数组) Go数组与C数组十分类似，数组是具有相同唯一类型的一组已编号且长度固定的数据项序列
关键字: 相同类型,长度固定，序列
slice(切片) type SliceHeader struct { Data uintptr // 底层数组的地址 	Len int // 长度 	Cap int // 容量 } Go 语言切片是对数组的抽象。结构中包含底层数组、长度、容量
初始化 array(数组) var numbers [5]int // 声明长度为5的数组,数组内容全为默认零值,int的零值为0 var numbers = [5]int{1, 2, 3, 4, 5} // 声明长度为5的数组,数组内容全为{}内的值。 [1 2 3 4 5] numbers := [5]int{1, 2, 3}// 声明长度为5的数组,数组内容全为{}内的值,少的部分为默认零值。 [1 2 3 0 0] numbers := [5]int{1, 2, 3, 4, 5, 6}// 由于{}内的值超过了数组超度编译不通过 numbers := [.</description>
    </item>
    
    <item>
      <title>1847_最近的房间</title>
      <link>/posts/leetcode/data/1847_%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%BF%E9%97%B4/</link>
      <pubDate>Mon, 16 Dec 2024 14:28:52 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1847_%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%BF%E9%97%B4/</guid>
      <description>力扣链接:1847. 最近的房间
 力扣难度 困难
算法评级: 8 掌握不同的数据结构与算法之间的关联性，处理复杂问题，掌握高级数据结构
难度分 2082
  题目：
一个酒店里有 n 个房间，这些房间用二维整数数组 rooms 表示，其中 rooms[i] = [roomIdi, sizei] 表示有一个房间号为 roomIdi 的房间且它的面积为 sizei 。每一个房间号 roomIdi 保证是 独一无二 的。
同时给你 k 个查询，用二维数组 queries 表示，其中 queries[j] = [preferredj, minSizej] 。第 j 个查询的答案是满足如下条件的房间 id ：
 房间的面积 至少 为 minSizej ，且abs(id - preferredj) 的值 最小 ，其中 abs(x) 是 x 的绝对值。  如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。</description>
    </item>
    
    <item>
      <title>Go每日一题_133</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_133/</link>
      <pubDate>Mon, 16 Dec 2024 13:37:34 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_133/</guid>
      <description>下面这段代码输出什么？
func hello(num ...int) { num[0] = 18 } func main() { i := []int{5, 6, 7} hello(i...) fmt.Println(i[0]) } A.18 B.5 C.Compilation error
🔑 答案解析：答 18
Go参数go只有值传递,函数调用每次都会创建一个新的副本，副本的值=原来的值。 &amp;hellip;int 本质上是个切片。切片的结构是 cap lan 底层数组指针
因此 num ...int 和 i... 的值内容是相同的。但是变量地址是不通的。
题目中没有触发扩容，因此2个切片指向同一个底层数组，因此num[0] = 18 会影响到外面的 i[0]
在线运行：
 本题: https://go.dev/play/p/ne8bmUzhqsN
num触发扩容后修改: https://go.dev/play/p/Y3BhAEj3CjL
copy深拷贝切片: https://go.dev/play/p/QZwRA6jL48z
 .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>1338_数组大小减半</title>
      <link>/posts/leetcode/data/1338_%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A/</link>
      <pubDate>Sun, 15 Dec 2024 15:36:23 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1338_%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A/</guid>
      <description>力扣链接:1338. 数组大小减半
力扣难度 中等
算法评级: 3 理解常用数据结构和算法
难度分 1303
 题目: 给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。
返回 至少 能删除数组中的一半整数的整数集合的最小大小
示例 1：
 输入：arr = [3,3,3,3,5,5,5,2,2,7] 输出：2 解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。 大小为 2 的可行集合有 {3,5},{3,2},{5,2}。 选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。
 示例 2：
 输入：arr = [7,7,7,7,7,7] 输出：1 解释：我们只能选择集合 {7}，结果数组为空。
 提示：
 1 &amp;lt;= arr.length &amp;lt;= 105 arr.length 为偶数 1 &amp;lt;= arr[i] &amp;lt;= 105   func minSetSize(arr []int) int { }  🧠思路: 👈点击猜想 贪心的想法，先遍历一遍记录出现次数。从频率最高的开始删除 问题就变为了怎么记录次数后从大到小排序方便.</description>
    </item>
    
    <item>
      <title>Go每日一题_132</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_132/</link>
      <pubDate>Sun, 15 Dec 2024 13:02:42 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_132/</guid>
      <description>下面这段代码输出什么？
type person struct { name string } func main() { var m map[person]int p := person{&amp;#34;mike&amp;#34;} fmt.Println(m[p]) } 🔑 答案解析：答 0
未初始化的map 读0值 写panic
在线运行：
 读未初始化的map: https://go.dev/play/p/yVjXasOREaH
写未初始化的map: https://go.dev/play/p/2zmJGtrH-8v
写已初始化的map: https://go.dev/play/p/eUh6csag8rh
 .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>3266_K_次乘运算后的最终数组_II</title>
      <link>/posts/leetcode/data/3266_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_ii/</link>
      <pubDate>Sat, 14 Dec 2024 12:13:03 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3266_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_ii/</guid>
      <description>力扣链接:3264. K 次乘运算后的最终数组 I
力扣难度 困难
算法评级: 8 掌握不同的数据结构与算法之间的关联性，处理复杂问题，掌握高级数据结构
难度分 2509
 题目: 给你一个整数数组 nums ，一个整数 k 和一个整数 multiplier 。
你需要对 nums 执行 k 次操作，每次操作中：
 找到 nums 中的 最小 值 x ，如果存在多个最小值，选择最 前面 的一个 将 x 替换为 x * multiplier 。  k 次操作以后，你需要将 nums 中每一个数值对 109 + 7 取余。 请你返回执行完 k 次乘运算以及取余运算之后，最终的 nums 数组。
示例 1：
 输入：nums = [2,1,3,5,6], k = 5, multiplier = 2
输出：[8,4,6,5,6]
解释：</description>
    </item>
    
    <item>
      <title>Go每日一题_131</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_131/</link>
      <pubDate>Sat, 14 Dec 2024 11:59:22 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_131/</guid>
      <description>关于 channel，下面语法正确的是：
 A. var ch chan int B. ch := make(chan int) C. &amp;lt;- ch D. ch &amp;lt;-  🔑 答案解析：A B C
A 声明变量ch 类型为 chan int，并未初始化 B 声明变量ch 类型为 chan int，并初始化 C 读channel，值抛弃 D 错误，写channel必须要值
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>3264_K_次乘运算后的最终数组_I</title>
      <link>/posts/leetcode/data/3264_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_i/</link>
      <pubDate>Fri, 13 Dec 2024 15:58:17 +0800</pubDate>
      
      <guid>/posts/leetcode/data/3264_k_%E6%AC%A1%E4%B9%98%E8%BF%90%E7%AE%97%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E6%95%B0%E7%BB%84_i/</guid>
      <description>力扣链接:3264. K 次乘运算后的最终数组 I
力扣难度 简单
算法评级: 3 理解常用数据结构和算法
难度分 1178
 题目: 给你一个整数数组 nums ，一个整数 k 和一个整数 multiplier 。
你需要对 nums 执行 k 次操作，每次操作中：
 找到 nums 中的 最小 值 x ，如果存在多个最小值，选择最 前面 的一个。 将 x 替换为 x * multiplier 。  请你返回执行完 k 次乘运算之后，最终的 nums 数组。
示例 1：
 输入：nums = [2,1,3,5,6], k = 5, multiplier = 2
输出：[8,4,6,5,6]
解释：
   操作 结果     1 次操作后 [2, 2, 3, 5, 6]   2 次操作后 [4, 2, 3, 5, 6]   3 次操作后 [4, 4, 3, 5, 6]   4 次操作后 [4, 4, 6, 5, 6]   5 次操作后 [8, 4, 6, 5, 6]     示例 2：</description>
    </item>
    
    <item>
      <title>Go每日一题_130</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_130/</link>
      <pubDate>Fri, 13 Dec 2024 15:43:57 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_130/</guid>
      <description>以下代码有什么问题？
package main import ( &amp;#34;sync&amp;#34; ) const N = 10 var wg = &amp;amp;sync.WaitGroup{} func main() { for i := 0; i &amp;lt; N; i++ { go func(i int) { wg.Add(1) println(i) defer wg.Done() }(i) } wg.Wait() } 🔑 答案解析：运行后的现象为什么都没有输出 WaitGroup(等待组)的目的是用于等待一组协程的结束。 内部会维护一个计数器 Add方法向内部计数加上delta Done方法减少WaitGroup计数器的值 Wait方法阻塞直到WaitGroup计数器减为0。
本题中,for 循环中go func 创建协程。 在协程运行是执行wg.Add(1)和wg.Done()
而在子goroutine运行前，主goroutine已经运行到wg.Wait()。这时候计数器为0因此不阻塞，main goroutine 结束后，进程结束。 因此子goroutine没有输出内容
修改：
func main() { for i := 0; i &amp;lt; N; i++ { wg.Add(1) // 1.</description>
    </item>
    
    <item>
      <title>2931_购买物品的最大开销</title>
      <link>/posts/leetcode/data/2931_%E8%B4%AD%E4%B9%B0%E7%89%A9%E5%93%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%80%E9%94%80/</link>
      <pubDate>Thu, 12 Dec 2024 13:58:44 +0800</pubDate>
      
      <guid>/posts/leetcode/data/2931_%E8%B4%AD%E4%B9%B0%E7%89%A9%E5%93%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%80%E9%94%80/</guid>
      <description>力扣链接:2931. 购买物品的最大开销
力扣难度 困难 算法评级: 6 难度分 1822
 题目:
给你一个下标从 0 开始大小为 m * n 的整数矩阵 values ，表示 m 个不同商店里 m * n 件不同的物品。每个商店有 n 件物品，第 i 个商店的第 j 件物品的价值为 values[i][j] 。除此以外，第 i 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 0 &amp;lt;= j &amp;lt; n - 1 都有 values[i][j] &amp;gt;= values[i][j + 1] 。
每一天，你可以在一个商店里购买一件物品。具体来说，在第 d 天，你可以：
 选择商店 i 。 购买数组中最右边的物品 j ，开销为 values[i][j] * d 。换句话说，选择该商店中还没购买过的物品中最大的下标 j ，并且花费 values[i][j] * d 去购买。  注意，所有物品都视为不同的物品。比方说如果你已经从商店 1 购买了物品 0 ，你还可以在别的商店里购买其他商店的物品 0 。</description>
    </item>
    
    <item>
      <title>Go每日一题_129</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_129/</link>
      <pubDate>Thu, 12 Dec 2024 00:59:04 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_129/</guid>
      <description>执行下面的代码会发生什么？
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch := make(chan int, 1000) go func() { for i := 0; i &amp;lt; 10; i++ { ch &amp;lt;- i } }() go func() { for { a, ok := &amp;lt;-ch if !ok { fmt.Println(&amp;#34;close&amp;#34;) return } fmt.Println(&amp;#34;a: &amp;#34;, a) } }() close(ch) fmt.Println(&amp;#34;ok&amp;#34;) time.Sleep(time.Second * 100) } 🔑 答案解析：okclosepanic: send on closed channelgoroutine 6 [running]:对已经关闭的管道写数据会发生panic 对已经关闭的管道读数据,无已写缓存的情况下读的是零值</description>
    </item>
    
    <item>
      <title>Go每日一题_128</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_128/</link>
      <pubDate>Wed, 11 Dec 2024 01:13:20 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_128/</guid>
      <description>下面这段代码能否编译通过？如果可以，输出什么？
func GetValue() int { return 1 } func main() { i := GetValue() switch i.(type) { case int: println(&amp;#34;int&amp;#34;) case string: println(&amp;#34;string&amp;#34;) case interface{}: println(&amp;#34;interface&amp;#34;) default: println(&amp;#34;unknown&amp;#34;) } } 🔑 答案解析：编译失败 i.(type) 类型断言的语法形如：i.(type)，其中 i 是接口，type 是固定关键字，需要注意的是，只有接口类型才可以使用类型断言。 官方：https://go.dev/tour/methods/16.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>2717_半有序排列</title>
      <link>/posts/leetcode/data/2717_%E5%8D%8A%E6%9C%89%E5%BA%8F%E6%8E%92%E5%88%97/</link>
      <pubDate>Wed, 11 Dec 2024 00:35:39 +0800</pubDate>
      
      <guid>/posts/leetcode/data/2717_%E5%8D%8A%E6%9C%89%E5%BA%8F%E6%8E%92%E5%88%97/</guid>
      <description>力扣链接:2717. 半有序排列
力扣难度 简单 算法评级: 3 理解常用数据结构和算法 难度分 1296
 题目:
给你一个下标从 0 开始、长度为 n 的整数排列 nums 。
如果排列的第一个数字等于 1 且最后一个数字等于 n，则称其为 半有序排列 。你可以执行多次下述操作，直到将 nums 变成一个 半有序排列 ：
 示例 1：
 输入：nums = [2,1,4,3] 输出：2 解释：可以依次执行下述操作得到半有序排列： 1 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。 2 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。 可以证明，要让 nums 成为半有序排列，不存在执行操作少于 2 次的方案。
 示例 2：
 输入：nums = [2,4,1,3] 输出：3 解释： 可以依次执行下述操作得到半有序排列： 1 - 交换下标 1 和下标 2 对应元素。排列变为 [2,1,4,3] 。 2 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。 3 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。 可以证明，要让 nums 成为半有序排列，不存在执行操作少于 3 次的方案。</description>
    </item>
    
    <item>
      <title>70_爬楼梯</title>
      <link>/posts/leetcode/data/70_%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Wed, 11 Dec 2024 00:29:39 +0800</pubDate>
      
      <guid>/posts/leetcode/data/70_%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>力扣链接:70.爬楼梯
力扣难度 简单 算法评级: 2 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 示例 1：
 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。
  1 阶 + 1 阶 2 阶  示例 2：
 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。
  1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶   func climbStairs(n int) int { }  🔑 答案解析： 👈点击.</description>
    </item>
    
    <item>
      <title>935_骑士拨号器</title>
      <link>/posts/leetcode/data/935_%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8/</link>
      <pubDate>Tue, 10 Dec 2024 20:20:24 +0800</pubDate>
      
      <guid>/posts/leetcode/data/935_%E9%AA%91%E5%A3%AB%E6%8B%A8%E5%8F%B7%E5%99%A8/</guid>
      <description>力扣链接:935. 骑士拨号器
力扣难度 中等 算法评级: 5 熟练掌握常用数据结构和算法，初步了解高级数据结构 难度分 1690 题目:
象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。
象棋骑士可能的移动方式如下图所示: 我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。 给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。
你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。
因为答案可能很大，所以输出答案模 109 + 7.
 示例 1：
 输入：n = 1 输出：10 解释：我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。
 示例 2：
 输入：n = 2 输出：20 解释：我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]
 示例 3：</description>
    </item>
    
    <item>
      <title>Go每日一题_127</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_127/</link>
      <pubDate>Tue, 10 Dec 2024 15:12:09 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_127/</guid>
      <description>下面这段代码输出什么以及原因？
func hello() []string { return nil } func main() { h := hello if h == nil { fmt.Println(&amp;#34;nil&amp;#34;) } else { fmt.Println(&amp;#34;not nil&amp;#34;) } }  A. nil B. not nil C. compilation error  🔑 答案解析：B
 hello 是个Function values.函数在GO中时一等公民。因此可以 if h == nil 有应为Function values.有值(地址)因此也不为nil 函数也是值。它们可以像其他值一样传递。 函数值可以用作函数参数和返回值。
 .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>服务设计_如何设计一个URL短链服务</title>
      <link>/posts/skill/data/%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1_%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAurl%E7%9F%AD%E9%93%BE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 09 Dec 2024 13:57:51 +0800</pubDate>
      
      <guid>/posts/skill/data/%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1_%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AAurl%E7%9F%AD%E9%93%BE%E6%9C%8D%E5%8A%A1/</guid>
      <description>什么是URL短链服务 URL短链服务的本质是通过HTTP 302重定向机制，将一个简短的URL重定向到原始的长URL。
短链服务解决了什么问题  解决消息发送的字数限制问题 例如，腾讯云SMS限制每条短信的字数为500个字符，而在营销短信中，通常会携带包含大量参数的URL（如邀请平台、邀请人、活动ID等）。这些参数使得URL变得非常冗长。通过URL短链服务，营销短信中的长URL可以被替换为一个简短的短链，节省了字数空间。  隐藏请求参数 以营销活动为例，URL中的常见参数可能包括活动ID等信息。如果我们不希望这些ID被随便修改，可以在参数中添加对应的活动ID KEY，这样只有当ID和KEY匹配时，用户才能进入相应的活动页面。然而，添加了KEY后，原本的URL会变得更加冗长。短链服务可以帮助隐藏这些请求参数，保持URL简洁且安全。  最基础的需求  长链登记 短链重定向  短链KEY为什么选择 Base62 编码 根据 RFC3986 标准，URL 由 ASCII 字符组成，以下字符可以安全地在 URL 中使用：
 字母（a-z 和 A-Z） 数字（0-9） 部分特殊字符：$-_.+!*&#39;(), 虽然RFC3986标准允许一些特殊字符，但有些特殊字符可能会对URL解析、传输或存储造成问题。例如，字符如 &amp;amp;, ?, =, # 等在查询参数或路径中有特定意义，因此它们可能引起冲突或产生解析错误。   为了避免这些潜在的麻烦，特别是在需要将复杂的查询参数或密钥编码为 URL 友好的格式时，我们通常会选择 Base62 编码，即只使用字母（大小写）和数字的组合。
 短链KEY的长度选择 我们字符集已经确定为Base62,因此长度为1 可以存储 62种。每增加一位，存储的极限数量会按 62 的指数增长。
   长度 存储极限 解释     1 62 1 位可以表示 62 种不同的组合   2 62 × 62 = 3,844 2 位可以表示 62 的平方，即 3,844 种不同的组合   3 62 × 62 × 62 = 238,328 3 位可以表示 62 的三次方，即 238,328 种不同的组合   4 62 × 62 × 62 × 62 = 14,776,336 4 位可以表示 62 的四次方，即 14,776,336 种不同的组合   5 62 × 62 × 62 × 62 × 62 = 916,132,832 5 位可以表示 62 的五次方，即 916,132,832种不同的组合   6 62 × 62 × 62 × 62 × 62 × 62 = 56,800,235,584 6 位可以表示 62 的六次方，即 56,800,235,584 种不同的组合     5位的存储极限已经达到916,132,832,这个数量已经非常大，足以支持大多数应用场景。然而，如果你希望进一步减少生成字符时的冲突、长远规划，选择 6 位 作为短链 KEY 长度会是一个不错的选择。</description>
    </item>
    
    <item>
      <title>浅谈GO GC (垃圾回收)</title>
      <link>/posts/skill/data/%E6%B5%85%E8%B0%88go-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Mon, 09 Dec 2024 13:03:08 +0800</pubDate>
      
      <guid>/posts/skill/data/%E6%B5%85%E8%B0%88go-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>垃圾回收   垃圾回收这里的垃圾指的是什么？为什么要回收？ 在程序运行的时候，进程会在堆内存申请内存空间。但是在函数退出的时候会栈空间会被销毁。因此这一段堆内存空间没有任何的指针指向它（没有被引用）。因此会造成内存的浪费（内存泄露）。这一段的没有被引用的内存就是“垃圾”。，程序员不再需要手动管理内存的分配和释放，从而减少了由于内存管理不当引起的内存泄漏或悬空指针等问题。
  常见的GC有哪几种
 手动垃圾回收，代表语言（C，C++） 标记-清扫算法  三色标记法   标记-整理算法  移动整理法 复制整理法   分代回收 引用计数    简述常见的GC如何实现，和他们各自的优缺点。
 手动垃圾回收：  实现：程序员自行调用函数销毁 优点：程序员对程序内存的掌控自由。 缺点：容易出现提前释放（悬挂指针）、忘记释放（内存泄漏)等问题。   标记-清扫算法：  实现：标记从根节点（栈内存、数据段）能追踪到的数据为游泳数据，其他未标记的数据就是垃圾数据，将对垃圾数据进行回收 优点：实现相对简单， 缺点：容易造成内存碎片化   标记-整理算法：  实现：  标记阶段与标记-清扫算法一致。 整理阶段：  移动整理法：整理移动有用的数据，使有用的数据尽可能紧凑的放在内存里。  优点：解决了内存碎片化的问题 缺点：多次扫描移动，会带来不小的性能开销   复制整理法：将内存划分为Form和To，将From空间中的有用数据都复制到To空间。并将Form和To空间的角色对换。  优点：解决了多次扫描移动的性能问题 缺点：内存使用率低。只有一半的堆内存空间被使用         分代回收：  实现：基于弱分代假说。将数据分为新生代、老年代。新生代、老年代采用不同的回收算法   引用计数  实现：每次对象应用都会更新对象的引用计数，当引用计数为0就回收该空间 优点：可以及时回收垃圾内存 缺点：高频更新引用计数会有不小性能开销，循环引用会导致引用计数永远不为0      什么是STW，为什么会有STW。 STW（stop the world）简单的就是让用户程序停下来。 STW期间，程序会进行垃圾回收</description>
    </item>
    
    <item>
      <title>1812_判断国际象棋棋盘中一个格子的颜色</title>
      <link>/posts/leetcode/data/1812_%E5%88%A4%E6%96%AD%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%A3%8B%E7%9B%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E9%A2%9C%E8%89%B2/</link>
      <pubDate>Mon, 09 Dec 2024 12:14:07 +0800</pubDate>
      
      <guid>/posts/leetcode/data/1812_%E5%88%A4%E6%96%AD%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%A3%8B%E7%9B%98%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%A0%BC%E5%AD%90%E7%9A%84%E9%A2%9C%E8%89%B2/</guid>
      <description>力扣链接:1812. 判断国际象棋棋盘中一个格子的颜色
力扣难度 简单
 题目: 给你一个坐标 coordinates ，它是一个字符串，表示国际象棋棋盘中一个格子的坐标。下图是国际象棋棋盘示意图。
如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。
给定坐标一定代表国际象棋棋盘上一个存在的格子。坐标第一个字符是字母，第二个字符是数字。
示例 1：
 输入：coordinates = &amp;ldquo;a1&amp;rdquo; 输出：false 解释：如上图棋盘所示，&amp;ldquo;a1&amp;rdquo; 坐标的格子是黑色的，所以返回 false 。
 示例 2：
 输入：coordinates = &amp;ldquo;h3&amp;rdquo; 输出：true 解释：如上图棋盘所示，&amp;ldquo;h3&amp;rdquo; 坐标的格子是白色的，所以返回 true 。
 示例 3：
 输入：coordinates = &amp;ldquo;c7&amp;rdquo; 输出：false
  func squareIsWhite(coordinates string) bool { } 🔑 答案解析： 👈点击func squareIsWhite(coordinates string) bool { return coordinates[0]%2 != coordinates[1]%2 } .toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_126</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_126/</link>
      <pubDate>Mon, 09 Dec 2024 11:58:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_126/</guid>
      <description>关于 init 函数，下面说法正确的是：
 A. 一个包中，可以包含多个 init 函数； B. 程序运行时，先执行依赖包的 init 函数，再执行 main 包内的 init 函数； C. main 包中，不能有 init 函数； D. init 函数可以被其他函数调用；  🔑 答案解析：A B
关于 init() 函数有几个需要注意的地方：
 init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等; 一个包可以出线多个 init() 函数,一个源文件也可以包含多个 init() 函数； 同一个包中多个 init() 函数的执行顺序没有明确定义，但是不同包的init函数是根据包导入的依赖关系决定的; init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误; 一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次； 引入包，不可出现死循坏。即A import B,B import A，这种情况编译失败；  .toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_125</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_125/</link>
      <pubDate>Sun, 08 Dec 2024 21:11:41 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_125/</guid>
      <description>今天给两道类似的题目，注意，有半数以上的人可能会做错！
题一:
package main func main() { var a int8 = -1 var b int8 = -128 / a println(b) } 题二：
package main func main() { const a int8 = -1 var b int8 = -128 / a println(b) } 上面2个问题能否通过编译,能编译通过的话会输出什么内容
🔑 答案解析：答: 题目一能通过编译 输出的是 -128 题目二不能通过编译 GO语言规范里面有这一句话
 对于带符号整数值来说， + , - , * , / 和 &amp;laquo; 运算可以合法地溢出，其产生的值是存在的并且可以被带符号整数表示法、其运算和操作数明确地定义 因此 -128/-1 = 128，int8的范围是 -128~127 这里的 128就越界了 128 的二进制表示是 10000000 正好是 -128 的补码。所以，第一题的结果是 -128。</description>
    </item>
    
    <item>
      <title>锁</title>
      <link>/posts/skill/data/%E9%94%81/</link>
      <pubDate>Sun, 08 Dec 2024 00:28:39 +0800</pubDate>
      
      <guid>/posts/skill/data/%E9%94%81/</guid>
      <description>计算机在并发的情况下很大可能会出现数据错乱的问题，因此运入了“锁”用于解决该类问题。 常见的锁：互斥锁、自旋锁、读写锁、悲观锁、乐观锁
互斥锁 特点：容易实现，最基础的锁概念
解释：在使用一个资源时，先上锁使用。上锁后其他线程都无法再上锁。直到解锁后，其他线程才能上锁使用。
生活例子：公共厕所，谁要上厕所就要先上锁后使用，避免其他人也闯入使用厕所。
自旋锁 自旋锁与互斥锁十分类似。 区别：
 自旋锁：加锁失败，线程还是会不断的去申请加锁，直到他拿到锁 互斥锁：加锁失败，线程会释放CPU资源，等待解锁后在申请上锁。  生活例子 -&amp;gt; 公共厕所 自旋锁：不断的在门口敲门，直到里面的人出来 互斥锁：不动了，直到里面的人出来叫你。
读写锁 顾名思义就是由读锁和写锁组成的。读数据往往是可以并发的读，并发写数据可能会导致数据不符合预期的情况
 读数据需要满足目前无写锁。 写数据需要满足目前无写锁、读锁。 生活例子：假设一个班级的考试成绩都写到同一个本子上。而学生会读成绩，老师会写成绩。学生看成绩可以同时看，而语文老师和数学老师不能并发的把成绩写到一页里。  读写锁可以分为 读优先锁 写优先锁 公平读写锁
  读优先锁 学生看到有老师在等待改写数据时，不理会老师继续读数据
  写优先锁
 读数据还需要满足无在等待的写锁  学生看到有老师在等待改写数据时，会主动让老师写数据。
  公平读写锁
 将读学请求放入一个队列，排队的去读写  学生和老师排个队伍
  乐观锁与悲观锁 互斥锁、自旋锁、读写锁都是悲观锁
悲观锁：多线程同时修改共享资源的概率比较高，容易发生冲突。因此访问共享资源前需要上锁。 乐观锁：认为发生冲突的概率比较低。并不会上任何的锁，而是校验该数据是否别修改过，修改过着放弃本次操作</description>
    </item>
    
    <item>
      <title>程序与内存之间的关系</title>
      <link>/posts/skill/data/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Sun, 08 Dec 2024 00:28:20 +0800</pubDate>
      
      <guid>/posts/skill/data/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</guid>
      <description>程序与内存之间的关系  数据类型本质：固定内存大小的别名 数据类型的作用：编译器预算对象(变量)分配的内存空间大小 内存四区:栈区(Stack),堆区(heap),全局区-静态全局变量区,全局区-常量区  运行流程说明  操作系统把物理硬盘代码load到内存 操作系统把代码分成四个区 操作系统找到main函数入口执行  内存四区:  栈区(Stack) :空间较小，要求数据读写性能高，数据存放时间较短暂。由编译器自动分配和释放，存放函数的参数值、函数的调用流程方法地址、局部变量等(局部变量如果产生逃逸现象，可能会挂在在堆区) 堆区(heap):空间充裕，数据存放时间较久。一般由开发者分配及释放(但是Golang中会根据变量的逃逸现象来选择是否分配到栈上或堆上)，启动Golang的GC由GC清除机制自动回收。 全局区-静态全局变量区:全局变量的开辟是在程序在main之前就已经放在内存中。而且对外完全可见。即作用域在全部代码中，任何同包代码均可随时使用，在变量会搞混淆，而且在局部函数中如果同名称变量使用:=赋值会出现编译错误。 全局变量最终在进程退出时，由操作系统回收。 全局区-常量区：常量区也归属于全局区，常量为存放数值字面值单位，即不可修改。或者说的有的常量是直接挂钩字面值的。  比如:
const cl = 10 cl是字面量10的对等符号。
所以在golang中，常量是无法取出地址的，因为字面量符号并没有地址而言。</description>
    </item>
    
    <item>
      <title>进程、线程、协程</title>
      <link>/posts/skill/data/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sun, 08 Dec 2024 00:28:02 +0800</pubDate>
      
      <guid>/posts/skill/data/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</guid>
      <description>从计算机的发展上,这概念从大到小的顺序是程序-&amp;gt;进程-&amp;gt;线程-&amp;gt;协程
 基础概念  进程：系统进行资源调度和分配的的基本单位 线程：线程是操作系统调度与执行的基础单位 协程：又称为用户级线程、微线程  核心点 进程  是操作系统资源调度的基础单位单元； 进程是能独立运行、独立获取资源的基本单位  线程  是操作系统最小调度单元； 创建、销毁、调度交由内核完成，cpu 需完成用户态与内核态间的切换； 可充分利用多核，实现并行.  协程  与线程存在映射关系，为 M：1； 创建、销毁、调度在用户态完成，对内核透明，所以更轻； 从属同一个内核级线程，无法并行；一个协程阻塞会导致从属同一线程的所有协程无法执行.  生活例子 CPU 电力 进程 工厂 线程 工厂部门
假设这个城市就一个工厂(进程)、 一个工厂部门(线程)、一条电线(单核)的情况。 这时候工厂(进程) 中的一个工厂部门(线程)，电线(单核)可以完全为他工作。
但是现在出现问题了，现在任务量太大了，工厂就划分了2个工厂部门(线程)，让这2个部门同时干活，但是现在只有一条电线(单核)，因此这2个部门不得不轮流用电（CPU时间片）。
但是现在又出现问题了，老板发现切换电源需要有资质的电工来操作（内核），每次切换的开销太大了。因此把这些让一个工厂部门(线程)长期通电，自己内部让原先2个部门的人轮流进去通电的工厂部门内工作。应为这是工厂内部的人员（用户态）调度，不涉及电工（内核态）。切换的代价相对较小，这就是协程</description>
    </item>
    
    <item>
      <title>原码、反码、补码、移码</title>
      <link>/posts/skill/data/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E7%A7%BB%E7%A0%81/</link>
      <pubDate>Sun, 08 Dec 2024 00:24:00 +0800</pubDate>
      
      <guid>/posts/skill/data/%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E7%A7%BB%E7%A0%81/</guid>
      <description>名词解释 原码:原码是最简单的整数表示方法，其中最高位用来表示符号（0表示正数，1表示负数），其余位表示数值的绝对值。例如，+5的原码是00000101，-5的原码是10000101。 反码:反码是通过对原码取反得到的，即将正数的原码保持不变，负数的原码的所有位取反（包括符号位）。例如，+5的反码是00000101（与原码相同），-5的反码是11111010。 补码:补码是计算机中最常用的整数表示方法。正数的补码与其原码相同，而负数的补码是其反码加1。补码的特点是在进行加减法运算时，不需要单独处理符号位。例如，+5的补码是00000101，-5的补码是11111011。 移码:移码是一种不常见的整数表示方法，在计算机领域中较少使用。它与补码类似，但是所有的数值都被偏移了一个固定的值，通常是一个中间值，以使得正数的表示始终比负数的表示更大。这种表示方法在某些特殊的硬件设计中可能会使用。 例子  原码为正数  整数 +10000 0001 // 原码0000 0001 // 反码 // 正数的 反码 = 原码0000 0001 // 补码 // 正数的 补码 = 反码 = 原码1000 0001 // 移码 // 移码 = 补码的符号位取反原码为0  整数 +00000 0000 // 原码0000 0000 // 反码 // 正数的 反码 = 原码0000 0000 // 补码 // 正数的 补码 = 反码 = 原码1000 0000 // 移码 // 移码 = 补码的符号位取反整数 -01000 0000 // 原码1111 1111 // 反码 // 负数的 反码 = 原码除符号位不变 其他全取反0000 0000 // 补码 // 负数的 补码 = 反码+1 //这里由于越界,取后8位则结果为8个01000 0000 // 移码 // 移码 = 补码的符号位取反原码为负数  整数 -11000 0001 // 原码1111 1110 // 反码 // 负数的 反码 = 原码除符号位不变 其他全取反1111 1111 // 补码 // 负数的 补码 = 反码+10110 1111 // 移码 // 移码 = 补码的符号位取反应用场景 原码：符合人类直觉，是最简单的整数表示方法</description>
    </item>
    
    <item>
      <title>688_骑士在棋盘上的概率</title>
      <link>/posts/leetcode/data/688_%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Sat, 07 Dec 2024 01:15:09 +0800</pubDate>
      
      <guid>/posts/leetcode/data/688_%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>力扣链接:688. 骑士在棋盘上的概率
力扣难度 中等
 题目:
在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。
象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格 每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。
骑士继续移动，直到它走了 k 步或离开了棋盘。
返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。
 示例 1：
 输入: n = 3, k = 2, row = 0, column = 0 输出: 0.0625 解释: 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。 在每一个位置上，也有两种移动可以让骑士留在棋盘上。 骑士留在棋盘上的总概率是0.0625。
 示例 2：
 输入: n = 1, k = 0, row = 0, column = 0 输出: 1.</description>
    </item>
    
    <item>
      <title>Go每日一题_124</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_124/</link>
      <pubDate>Sat, 07 Dec 2024 00:36:19 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_124/</guid>
      <description>以下代码输出什么？
package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { t := struct { time.Time N int }{ time.Date(2020, 12, 20, 0, 0, 0, 0, time.UTC), 5, } m, _ := json.Marshal(t) fmt.Printf(&amp;#34;%s&amp;#34;, m) } A：{&amp;ldquo;Time&amp;rdquo;: &amp;ldquo;2020-12-20T00:00:00Z&amp;rdquo;, &amp;ldquo;N&amp;rdquo;: 5 }；B：&amp;ldquo;2020-12-20T00:00:00Z&amp;rdquo;；C：{&amp;ldquo;N&amp;rdquo;: 5}；D：&amp;lt;nil&amp;gt;
🔑 答案解析：答 B 题中time.Time 是内嵌到匿名struct 中的，也就是继承了time.Time 。 time.Time 的重写了MarshalJSON 方法因此会按照time.Time 的MarshalJSON 规定的格式输出.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_123</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_123/</link>
      <pubDate>Fri, 06 Dec 2024 23:55:50 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_123/</guid>
      <description>以下代码打印出来什么内容，说出为什么。
package main import ( &amp;#34;fmt&amp;#34; ) type People interface { Show() } type Student struct{} func (stu *Student) Show() { } func live() People { var stu *Student return stu } func main() { if live() == nil { fmt.Println(&amp;#34;AAAAAAA&amp;#34;) } else { fmt.Println(&amp;#34;BBBBBBB&amp;#34;) } } 🔑 答案解析：答：BBBBBBB 简单来说,接口变量有2个值,一个是类型,另一个是值。 if 接口 时,值和类型都为零值时,接口live() == nil 判断才为T
接口interface内部结构 interface共有2种表现形式
// 1 空接口 var MyInterface interface{} // 2 非空接口 type MyInterface interface { function() } 对应的2种底层结构</description>
    </item>
    
    <item>
      <title>Go每日一题_122</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_122/</link>
      <pubDate>Fri, 06 Dec 2024 23:43:05 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_122/</guid>
      <description>以下代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { var ans float64 = 15 + 25 + 5.2 fmt.Println(ans) } 🔑 答案解析：答：45.2.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_121</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_121/</link>
      <pubDate>Fri, 06 Dec 2024 23:43:04 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_121/</guid>
      <description>下面代码会输出什么
func increaseA() int { var i int defer func() { i++ }() return i } func increaseB() (r int) { defer func() { r++ }() return r } func main() { fmt.Println(increaseA()) fmt.Println(increaseB()) } 🔑 答案解析：0 1 上方2个函数的区别在于increaseA() 的返回参数是匿名，increaseB() 是具名。 A 执行到return i 是将i的值赋值给返回参数，后面i++不影响 B 执行到return r 是将r赋值给r,后面的r++ 因为是同一个r 后面的r++会影响
func increaseB() (r int) { defer func() { r++ }() return 4 } // 返回5 上面的代码就可以证明return 4 赋值给了r</description>
    </item>
    
    <item>
      <title>Go每日一题_120</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_120/</link>
      <pubDate>Fri, 06 Dec 2024 23:43:03 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_120/</guid>
      <description>下面代码中，x 已声明，y 没有声明，判断每条语句的对错。
A: x, _ := f() B: x, _ = f() C: x, y := f() D: x, y = f() 🔑 答案解析：A错、B对、C对、D错.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_119</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_119/</link>
      <pubDate>Fri, 06 Dec 2024 23:43:01 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_119/</guid>
      <description>有下面 3 行代码：
下面代码输出什么？
// 32 位机器 1）var x int32 = 32.0 2）var y int = x 3）var z rune = x 它们是否能编译通过？为什么？
如果面试时问这道题，你需要想想面试官想考察你什么。 🔑 答案解析：参考答案及解析： 答 不能通过编译
 这里是允许的 因为 32.0 是无类型字面量 可以 赋值给 int32 2）int 在32位机器占32位 在 64位机器占64位，题中int 虽然和 int32 占相同的空间，但是因为是不同的类型 无法赋值 编译错误 3）rune是int32 的别名，可以通过编译  .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_118</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_118/</link>
      <pubDate>Fri, 06 Dec 2024 23:43:00 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_118/</guid>
      <description>Go101 发布的一条 twitter。以下代码是否能正常运行，结果是？ 下面代码输出什么？
package main func main() { v := new(int) *v = 2 println(5/+-*v) } 🔑 答案解析：参考答案及解析：B。
Go 中有如下几个一元运算符
unary_op = &amp;#34;+&amp;#34; | &amp;#34;-&amp;#34; | &amp;#34;!&amp;#34; | &amp;#34;^&amp;#34; | &amp;#34;*&amp;#34; | &amp;#34;&amp;amp;&amp;#34; | &amp;#34;&amp;lt;-&amp;#34; . 因此会先计算 5/+-*v 又因为规范
 对于整数操作数，一元运算符 + , - 和 ^ 有如下定义：（省略了 ^ 的解释） +x 是 0 + x -x 取其负值 是 0 - x
 因此转化后 5 / [0+(0-*v)] 、 5 / -2</description>
    </item>
    
    <item>
      <title>Go每日一题_117</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_117/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:59 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_117/</guid>
      <description>下面代码输出什么？
type A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { c := Work{3} var a A = c var b B = c fmt.Println(a.ShowB()) fmt.Println(b.ShowA()) } A. 23 13 B. compilation error 🔑 答案解析：参考答案及解析：B。</description>
    </item>
    
    <item>
      <title>Go每日一题_116</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_116/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:57 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_116/</guid>
      <description>下面这段代码输出什么？
type A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { c := Work{3} var a A = c var b B = c fmt.Println(a.ShowA()) fmt.Println(b.ShowB()) } 🔑 答案解析：答 可以成功编译 且输出 13 和 23</description>
    </item>
    
    <item>
      <title>Go每日一题_115</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_115/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:56 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_115/</guid>
      <description>对 add() 函数调用正确的是？
func add(args ...int) int { sum := 0 for _, arg := range args { sum += arg } return sum } A. add(1, 2) B. add(1, 3, 7) C. add([]int{1, 2}) D. add([]int{1, 3, 7}&amp;hellip;) 🔑 答案解析：参考答案及解析：ABD。
知识点：可变函数。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_114</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_114/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:55 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_114/</guid>
      <description>下面这段代码能否通过编译，如果可以，输出什么？
func main() { s1 := []int{1, 2, 3} s2 := []int{4, 5} s1 = append(s1, s2) fmt.Println(s1) } 🔑 答案解析：答：不能通过编译。append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_113</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_113/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:54 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_113/</guid>
      <description>f1()、f2()、f3() 函数分别返回什么？
package main import ( &amp;#34;fmt&amp;#34; ) func f1() (r int) { defer func() { r++ }() return 0 } func f2() (r int) { t := 5 defer func() { t = t + 5 }() return t } func f3() (r int) { defer func(r int) { r = r + 5 }(r) return 1 } func main() { fmt.Println(f1()) fmt.Println(f2()) fmt.Println(f3()) } 🔑 答案解析：参考答案及解析：1 5 1。</description>
    </item>
    
    <item>
      <title>Go每日一题_112</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_112/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_112/</guid>
      <description>下面代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) type A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { var a A = Work{3} // 类型断言 	// http://c.biancheng.net/view/4281.html 	s := a.(Work) fmt.Println(s.ShowA()) fmt.Println(s.ShowB()) }  A.</description>
    </item>
    
    <item>
      <title>Go每日一题_111</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_111/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:51 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_111/</guid>
      <description>下面代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) func increaseA() int { var i int defer func() { i++ }() return i } func increaseB() (r int) { defer func() { r++ }() return r } func main() { fmt.Println(increaseA()) fmt.Println(increaseB()) } A. 1 1 B. 0 1 C. 1 0 D. 0 0 🔑 答案解析：参考答案及解析：B。
知识点：defer、返回值。注意一下，increaseA() 的返回参数是匿名，increaseB() 是具名。关于 defer 与返回值的知识点，后面我会写篇文章详细分析，到时候可以看下文章的讲解。
.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_110</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_110/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:50 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_110/</guid>
      <description>如果 Add() 函数的调用代码为：
func main() { var a Integer = 1 var b Integer = 2 var i interface{} = &amp;amp;a sum := i.(*Integer).Add(b) fmt.Println(sum) } 则Add函数定义正确的是：
A. type Integer int func (a Integer) Add(b Integer) Integer { return a + b } B. type Integer int func (a Integer) Add(b *Integer) Integer { return a + *b } C. type Integer int func (a *Integer) Add(b Integer) Integer { return *a + b } D.</description>
    </item>
    
    <item>
      <title>Go每日一题_109</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_109/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:49 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_109/</guid>
      <description>关于switch语句，下面说法正确的有?
A. 条件表达式必须为常量或者整数； B. 单个case中，可以出现多个结果选项； C. 需要用break来明确退出一个case； D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；
🔑 答案解析：BD A 是可以放表达式的 C 不需要使用break.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_108</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_108/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:48 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_108/</guid>
      <description>关于类型转化，下面选项正确的是？
A. type MyInt int var i int = 1 var j MyInt = i B. type MyInt int var i int = 1 var j MyInt = (MyInt)i C. type MyInt int var i int = 1 var j MyInt = MyInt(i) D. type MyInt int var i int = 1 var j MyInt = i.(MyInt) 🔑 答案解析：C.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_107</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_107/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:46 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_107/</guid>
      <description>下面代码输出正确的是？
func main() { i := 1 s := []string{&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;} i, s[i-1] = 2, &amp;#34;Z&amp;#34; fmt.Printf(&amp;#34;s: %v \n&amp;#34;, s) } A. s: [Z,B,C] B. s: [A,Z,C]
🔑 答案解析：A
平行赋值a[i], a[j] = a[j], a[i]
多重赋值分为两个步骤，有先后顺序： 计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式； 赋值； 所以本例，会先计算 s[i-1]，等号右边是两个表达式是常量，所以赋值运算等同于 i, s[0] = 2, &amp;ldquo;Z&amp;rdquo;。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_106</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_106/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:45 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_106/</guid>
      <description>关于循环语句，下面说法正确的有（）
A. 循环语句既支持 for 关键字，也支持 while 和 do-while； B. 关键字 for 的基本使用方法与 C/C++ 中没有任何差异； C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环； D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；
🔑 答案解析：CD 平行赋值a[i], a[j] = a[j], a[i].toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_105</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_105/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:44 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_105/</guid>
      <description>下面代码里的 counter 的输出值？
func main() { var m = map[string]int{ &amp;#34;A&amp;#34;: 21, &amp;#34;B&amp;#34;: 22, &amp;#34;C&amp;#34;: 23, } counter := 0 for k, v := range m { if counter == 0 { delete(m, &amp;#34;A&amp;#34;) } counter++ fmt.Println(k, v) } fmt.Println(&amp;#34;counter is &amp;#34;, counter) } 🔑 答案解析：C map是引用类型 会影响原map.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_104</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_104/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:43 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_104/</guid>
      <description>下面这段代码输出结果正确吗？
type Foo struct { bar string } func main() { s1 := []Foo{ {&amp;#34;A&amp;#34;}, {&amp;#34;B&amp;#34;}, {&amp;#34;C&amp;#34;}, } s2 := make([]*Foo, len(s1)) for i, value := range s1 { s2[i] = &amp;amp;value } fmt.Println(s1[0], s1[1], s1[2]) fmt.Println(s2[0], s2[1], s2[2]) } 输出： {A} {B} {C} &amp;amp;{A} &amp;amp;{B} &amp;amp;{C} 🔑 答案解析：go 1.22 后输出是正常的 go &amp;lt; 1.22 for range 循环会重复使用value变量 value的地址都是同一个，因此输出s2 会变成CCC.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_103</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_103/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:42 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_103/</guid>
      <description>下面这段代码输出什么？
func main() { var a = []int{1, 2, 3, 4, 5} var r [5]int for i, v := range a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(&amp;#34;r = &amp;#34;, r) fmt.Println(&amp;#34;a = &amp;#34;, a) } 🔑 答案解析：r = [1 12 13 4 5] a = [1 12 13 4 5] rang a 实际是在变量a的副本。由于切片的结构，这2个切片都会指向同一个底层数组。因此改动	a[1] = 12 ， a[2] = 13 会影响v的结构</description>
    </item>
    
    <item>
      <title>Go每日一题_102</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_102/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:41 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_102/</guid>
      <description>下面这段代码输出什么？
func change(s ...int) { s = append(s,3) } func main() { slice := make([]int,5,5) slice[0] = 1 slice[1] = 2 change(slice...) fmt.Println(slice) change(slice[0:2]...) fmt.Println(slice) } 🔑 答案解析：[1 2 0 0 0][1 2 3 0 0]知识点：可变函数、append()操作。
Go 提供的语法糖&amp;hellip;，可以将 slice 传进可变函数，不会创建新的切片。第一次调用 change() 时，append() 操作使切片底层数组发生了扩容，原 slice 的底层数组不会改变； 第二次调用change() 函数时，使用了操作符[i,j]获得一个新的切片，假定为 slice1， 它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，所以在 change() 函数中对 slice1 底层数组的修改会影响到原切片。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_101</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_101/</link>
      <pubDate>Fri, 06 Dec 2024 23:42:39 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_101/</guid>
      <description>下面这段代码输出什么？
func main() { var a = [5]int{1, 2, 3, 4, 5} var r [5]int for i, v := range a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(&amp;#34;r = &amp;#34;, r) fmt.Println(&amp;#34;a = &amp;#34;, a) } 🔑 答案解析：r = [1 2 3 4 5] a = [1 12 13 4 5] range 表达式是副本参与循环，就是说例子中参与循环的是 a 的副本，而不是真正的 a。.</description>
    </item>
    
    <item>
      <title>Go每日一题_100</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_100/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:29 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_100/</guid>
      <description>下面这段代码输出什么？
package main import &amp;#34;fmt&amp;#34; func f(n int) (r int) { defer func() { r += n recover() }() var f func() defer f() f = func() { r += 2 } return n + 1 } func main() { fmt.Println(f(3)) } 🔑 答案解析：7
// 先执行这一段代码, 然后 r 被赋值为 4 return n+1 // 然后执行，但是会触发panic defer f() // 最后执行，r 再加3 r=7,然后recover(),最后函数返回 7 defer func() { r += n recover() }() .</description>
    </item>
    
    <item>
      <title>Go每日一题_099</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_099/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:28 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_099/</guid>
      <description>下面这段代码输出什么？为什么？
func main() { var m = [...]int{1, 2, 3} for i, v := range m { go func() { fmt.Println(i, v) }() } time.Sleep(time.Second * 3) } 🔑 答案解析：go 1.22 前会出现 2 3 2 3 2 3 for range 使用短变量声明 (:=) 的形式迭代变量，需要注意的是，变量 i、v 在每次循环体中都会被重用，而不是重新声明。
各个 goroutine 中输出的 i、v 值都是 for range 循环结束后的 i、v 最终值，而不是各个 goroutine 启动时的 i, v值。可以理解为闭包引用，使用的是上下文环境的值。两种可行的 fix 方法:
.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_098</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_098/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:26 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_098/</guid>
      <description>下面这段代码能否正常结束？
func main() { v := []int{1, 2, 3} for i := range v { v = append(v, i) } } 🔑 答案解析：不会出现死循环，能正常结束。
循环次数在循环开始前就已经确定，循环内改变切片的长度，不影响循环次数
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_097</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_097/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:25 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_097/</guid>
      <description>下面这段代码输出什么？
var p *int func foo() (*int, error) { var i int = 5 return &amp;amp;i, nil } func bar() { //use p 	fmt.Println(*p) } func main() { p, err := foo() if err != nil { fmt.Println(err) return } bar() fmt.Println(*p) } A. 5 5 B. runtime error
🔑 答案解析：B 全局的 *p 是nil p, err := foo() 这里是一个新的p 局部变量 与全局的p无关.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_096</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_096/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:24 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_096/</guid>
      <description>下面的代码有什么问题？
func main() { fmt.Println([...]int{1} == [2]int{1}) fmt.Println([]int{1} == []int{1}) } 🔑 答案解析：有两处错误
go 中不同类型是不能比较的，而数组长度是数组类型的一部分，所以 [&amp;hellip;]int{1} 和 [2]int{1} 是两种不同的类型，不能比较； 切片是不能比较的；
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_095</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_095/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:23 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_095/</guid>
      <description>以下代码的输出结果：
package main import &amp;#34;sync&amp;#34; func main() { var wg sync.WaitGroup foo := make(chan int) bar := make(chan int) wg.Add(1) go func() { defer wg.Done() select { case foo &amp;lt;- &amp;lt;-bar: default: println(&amp;#34;default&amp;#34;) } }() wg.Wait() } A：default B：panic 🔑 答案解析：按常规理解，go func 中的 select 应该执行 default 分支，程序正常运行。但结果却不是，而是死锁。可以通过该链接测试：https://play.studygolang.com/p/kF4pOjYXbXf。
原因文章也解释了，Go 语言规范中有这么一句：
 For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the “select” statement.</description>
    </item>
    
    <item>
      <title>Go每日一题_094</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_094/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:22 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_094/</guid>
      <description>下面代码输出什么？
type Math struct { x, y int } var m = map[string]Math{ &amp;#34;foo&amp;#34;: Math{2, 3}, } func main() { m[&amp;#34;foo&amp;#34;].x = 4 fmt.Println(m[&amp;#34;foo&amp;#34;].x) } A. 4 B. compilation error
🔑 答案解析：参考答案及解析：B，编译报错 cannot assign to struct field m[&amp;ldquo;foo&amp;rdquo;].x in map。错误原因：对于类似 X = Y的赋值操作，必须知道 X 的地址，才能够将 Y 的值赋给 X，但 go 中的 map 的 value 本身是不可寻址的。
有两个解决办法：
a.使用临时变量
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_093</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_093/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:21 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_093/</guid>
      <description>下面这段代码输出什么？
type Direction int const ( North Direction = iota East South West ) func (d Direction) String() string { return [...]string{&amp;#34;North&amp;#34;, &amp;#34;East&amp;#34;, &amp;#34;South&amp;#34;, &amp;#34;West&amp;#34;}[d] } func main() { fmt.Println(South) } 🔑 答案解析：参考答案及解析：South。知识点：iota 的用法、类型的 String() 方法。
根据 iota 的用法推断出 South 的值是 2；另外，如果类型定义了 String() 方法，当使用 fmt.Printf()、fmt.Print() 和 fmt.Println() 会自动使用 String() 方法，实现字符串的打印。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_092</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_092/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:19 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_092/</guid>
      <description>下面这段代码输出什么？为什么？
type People interface { Show() } type Student struct{} func (stu *Student) Show() { } func main() { var s *Student if s == nil { fmt.Println(&amp;#34;s is nil&amp;#34;) } else { fmt.Println(&amp;#34;s is not nil&amp;#34;) } var p People = s if p == nil { fmt.Println(&amp;#34;p is nil&amp;#34;) } else { fmt.Println(&amp;#34;p is not nil&amp;#34;) } } 🔑 答案解析：参考答案及解析：s is nil 和 p is not nil。</description>
    </item>
    
    <item>
      <title>Go每日一题_091</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_091/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:18 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_091/</guid>
      <description>下面这段代码输出什么？
const ( a = iota b = iota ) const ( name = &amp;#34;name&amp;#34; c = iota d = iota ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) } 🔑 答案解析：参考答案及解析：0 1 1 2。
知识点：iota 的用法。
iota 是 golang 语言的常量计数器，只能在常量的表达式中使用。
iota 在 const 关键字出现时将被重置为0，const中每新增一行常量声明将使 iota 计数一次。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_090</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_090/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:17 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_090/</guid>
      <description>下面这段代码输出什么？为什么？
type People interface { Speak(string) string } type Student struct{} func (stu *Student) Speak(think string) (talk string) { if think == &amp;#34;speak&amp;#34; { talk = &amp;#34;speak&amp;#34; } else { talk = &amp;#34;hi&amp;#34; } return } func main() { var peo People = Student{} think := &amp;#34;speak&amp;#34; fmt.Println(peo.Speak(think)) } A. speak B. compilation error
🔑 答案解析：B 编译错误 Student does not implement People (Speak method has pointer receiver)，值类型 Student 没有实现接口的 Speak() 方法，而是指针类型 *Student 实现改方法。.</description>
    </item>
    
    <item>
      <title>Go每日一题_089</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_089/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:16 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_089/</guid>
      <description>下面这段代码输出什么？为什么？
func (i int) PrintInt () { fmt.Println(i) } func main() { var i int = 1 i.PrintInt() } 🔑 答案解析：会编译错误，只有自定义类型且与类型定义在同一个包内才能创建对应的方法
参考答案及解析：B。
基于类型创建的方法必须定义在同一个包内，上面的代码基于 int 类型创建了 PrintInt() 方法，由于 int 类型和方法 PrintInt() 定义在不同的包内，所以编译出错。解决的办法可以定义一种新的类型：
type Myint int func (i Myint) PrintInt () { fmt.Println(i) } func main() { var i Myint = 1 i.PrintInt() } .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_088</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_088/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:15 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_088/</guid>
      <description>以下代码输出什么：
package main func main() { var x *struct { s [][32]byte } println(len(x.s[99])) } A：运行时 panic；B：32；C：编译错误；D：0 🔑 答案解析：答案B
 返回结果总是 int； 返回结果有可能是常量； 有时对函数参数不求值，即编译期确定返回值；  这里 len(x.s[99]) 因为s的切片类型是[32]byte，因此得len(x.s[99]) = 32
这里要清楚 len 和 cap 是不会panic的是编译器完成的功能 表达式 x.s[99] 没有包含 channel 接收也不是函数调用，因此在编译阶段就已经确定返回的值
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_087</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_087/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:13 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_087/</guid>
      <description>下面这段代码输出什么？
func main() { a := 1 b := 2 defer calc(&amp;#34;1&amp;#34;, a, calc(&amp;#34;10&amp;#34;, a, b)) a = 0 defer calc(&amp;#34;2&amp;#34;, a, calc(&amp;#34;20&amp;#34;, a, b)) b = 1 } func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } 🔑 答案解析：10 1 2 320 0 2 22 0 2 21 1 3 4程序执行到 main() 函数三行代码的时候，会先执行 calc() 函数的 b 参数，即：calc(&amp;ldquo;10&amp;rdquo;,a,b)，输出：10 1 2 3，得到值 3，因为 defer 定义的函数是延迟函数，故 calc(&amp;ldquo;1&amp;rdquo;,1,3) 会被延迟执行；</description>
    </item>
    
    <item>
      <title>Go每日一题_086</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_086/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:12 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_086/</guid>
      <description>下面这段代码输出什么？
func main() { m := map[int]string{0:&amp;#34;zero&amp;#34;,1:&amp;#34;one&amp;#34;} for k,v := range m { fmt.Println(k,v) } } 🔑 答案解析：0 zero1 one// 或者1 one0 zeromap 的输出是无序的。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_085</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_085/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:11 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_085/</guid>
      <description>下面选项正确的是？
func main() { if a := 1; false { } else if b := 2; false { } else { println(a, b) } } A. 1 2 B. compilation error 🔑 答案解析：涉及到 代码块的问题。 具体可以看这篇文章 https://studygolang.com/articles/35587 化解出来后该代码变为
{ a := 1 if false { } else { b := 2 if false { } else { println(a, b) } } } .toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_084</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_084/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:10 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_084/</guid>
      <description>下面这段代码输出什么？为什么？
func main() { s1 := []int{1, 2, 3} s2 := s1[1:] s2[1] = 4 fmt.Println(s1) s2 = append(s2, 5, 6, 7) fmt.Println(s1) } 🔑 答案解析：s1 [1,2,4] s2 [2,4,5,6,7].toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_083</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_083/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:09 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_083/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go每日一题_082</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_082/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:07 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_082/</guid>
      <description>下面的代码有几处语法问题，各是什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { var x string = nil if x == nil { x = &amp;#34;default&amp;#34; } fmt.Println(x) } 🔑 答案解析：1、var x string = nil string 不能为nil 2、 if x == nil { string 不能与nil 比较.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_081</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_081/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:06 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_081/</guid>
      <description>以下代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { var ans float64 = 15 + 25 + 5.2 fmt.Println(ans) } A：不能编译；B：45；C：45.2；D：45.0
🔑 答案解析：C 数字是无类型常量 或者说是任意类型.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_080</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_080/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:05 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_080/</guid>
      <description>下面 A、B 两处应该填入什么代码，才能确保顺利打印出结果？
type S struct { m string } func f() *S { return __ //A } func main() { p := __ //B 	fmt.Println(p.m) //print &amp;#34;foo&amp;#34; } 🔑 答案解析：A. &amp;amp;S{&amp;ldquo;foo&amp;rdquo;} B. *f() 或者 f()
f() 函数返回参数是指针类型，所以可以用 &amp;amp; 取结构体的指针；B 处，如果填 *f()，则 p 是 S 类型；如果填 f()，则 p 是 *S 类型，不过都可以使用 p.m 取得结构体的成员。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_079</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_079/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:04 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_079/</guid>
      <description>A、B、C、D 哪些选项有语法错误？
type S struct { } func f(x interface{}) { } func g(x *interface{}) { } func main() { s := S{} p := &amp;amp;s f(s) //A 	g(s) //B 	f(p) //C 	g(p) //D } 🔑 答案解析：参考答案及解析：BD。
函数参数为 interface{} 时可以接收任何类型的参数，包括用户自定义类型等，即使是接收指针类型也用 interface{}，而不是使用 *interface{}。
 永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。
 .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_078</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_078/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:03 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_078/</guid>
      <description>下面的两个切片声明中有什么区别？哪个更可取？
A. var a []int B. a := []int{} 🔑 答案解析：A 声明的 []int 未初始化 指向的nil B 声明的 []int 是已经初始化的 指向的内容为空的数组。
A 可以写到全局 B 只能写到函数内
A 与 B 占用的内存空间理论上是相同的。 注意：空切片empty slice 指向了一个固定地址，所以实际上确实没有分配内存。
但是B比A 多指向的内容为空的数组，这个操作也会消耗而外性能(🤏),在性能的角度上A具有优势
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_077</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_077/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:01 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_077/</guid>
      <description>下面代码输出什么？
type Person struct { age int } func main() { person := &amp;amp;Person{28} // 1. 	defer fmt.Println(person.age) // 2. 	defer func(p *Person) { fmt.Println(p.age) }(person) // 3. 	defer func() { fmt.Println(person.age) }() person = &amp;amp;Person{29} } 🔑 答案解析：29 28 28
注意// 2 这里传入的person指向的地址 与后面person = &amp;amp;Person{29}后person 指向的地址不同
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_076</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_076/</link>
      <pubDate>Fri, 06 Dec 2024 20:45:00 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_076/</guid>
      <description>下面这段代码正确的输出是什么？
func f() { defer fmt.Println(&amp;#34;D&amp;#34;) fmt.Println(&amp;#34;F&amp;#34;) } func main() { f() fmt.Println(&amp;#34;M&amp;#34;) } 🔑 答案解析：FDM.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_075</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_075/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:59 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_075/</guid>
      <description>下面代码段输出什么？
type Person struct { age int } func main() { person := &amp;amp;Person{28} // 1. 	defer fmt.Println(person.age) // 2. 	defer func(p *Person) { fmt.Println(p.age) }(person) // 3. 	defer func() { fmt.Println(person.age) }() person.age = 29 } 🔑 答案解析：29 29 28 defer是先进后出的 因此会运行 // 3 的内容 输出29 后运行 //2 这里传入的是指针类型，因此会数据也是29 最后运行//1 因为入参的值在运行defer就已经定下来了 因此输出28.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_074</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_074/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:58 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_074/</guid>
      <description>以下代码输出什么？
package main import &amp;#34;fmt&amp;#34; func app() func(string) string { t := &amp;#34;Hi&amp;#34; c := func(b string) string { t = t + &amp;#34; &amp;#34; + b return t } return c } func main() { a := app() b := app() a(&amp;#34;go&amp;#34;) fmt.Println(b(&amp;#34;All&amp;#34;)) fmt.Println(a(&amp;#34;All&amp;#34;)) } A：Hi All；B：Hi go All；C：Hi；D：go Al 🔑 答案解析：闭包 fmt.Println(b(&amp;ldquo;All&amp;rdquo;)) 输出 A （Hi All） fmt.Println(a(&amp;ldquo;All&amp;rdquo;)) 输出 B （Hi go All）.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_073</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_073/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:57 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_073/</guid>
      <description>f1()、f2()、f3() 函数分别返回什么？
func f1() (r int) { defer func() { r++ }() return 0 } func f2() (r int) { t := 5 defer func() { t = t + 5 }() return t } func f3() (r int) { defer func(r int) { r = r + 5 }(r) return 1 } 🔑 答案解析：f1 1 f2 5 f3 1.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_072</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_072/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:55 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_072/</guid>
      <description>下面代码输出什么？
type A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { var a A = Work{3} s := a.(Work) fmt.Println(s.ShowA()) fmt.Println(s.ShowB()) } A. 13 23 B. compilation error 🔑 答案解析：A ：类型断言。 无坑.</description>
    </item>
    
    <item>
      <title>Go每日一题_071</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_071/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:54 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_071/</guid>
      <description>下面代码输出什么？
func increaseA() int { var i int defer func() { i++ }() return i } func increaseB() (r int) { defer func() { r++ }() return r } func main() { fmt.Println(increaseA()) fmt.Println(increaseB()) } A. 1 1 B. 0 1 C. 1 0 D. 0 0 🔑 答案解析：参考答案及解析：B。
知识点：defer、返回值。注意一下，increaseA() 的返回参数是匿名，increaseB() 是具名。 increaseA return r 已经将r的值 返回了 r再改变并不影响
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_070</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_070/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:53 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_070/</guid>
      <description>下面代码中，x 已声明，y 没有声明，判断每条语句的对错。
x, _ := f() x, _ = f() x, y := f() x, y = f()
🔑 答案解析：1 错 2 对 3 对 4 错 变量的声明。1.错，x 已经声明，不能使用 :=；2.对；3.对，当多值赋值时，:= 左边的变量至少要有一个未声明的；4.错，y 没有声明。.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_069</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_069/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_069/</guid>
      <description>有下面 3 行代码：
// 32 位机器 1）var x int32 = 32.0 2）var y int = x 3）var z rune = x 它们是否能编译通过？为什么？
如果面试时问这道题，你需要想想面试官想考察你什么。 🔑 答案解析：数字字面量 在 Go 语言中，字面量是无类型（untyped）的。无类型是什么意思？无类型意味着可以赋值给类似类型的变量或常量。用上面例子，32.0 是无类型的浮点数字面量，因此它可以赋值给任意数字相关类型变量（或常量）。以下都是合法的：
var a int64 = 32.0 var b int = 32.0 var c float32 = 32.0 var d complex64 = 32.0 var e byte = 32.0 var f rune = 32.0 所以上题中 1）是正确的。
不同类型 在目前 Go 1.16 版本中（实际上只有很早期的版本不是），int 类型在 32 位机器占 4 字节，64 位机器占 8 字节。所以，在 32 位机器上，int32 和 int 的内存占用和内存布局是完全一样的。但 Go 语言不会做隐式类型转换，int 和 int32 是不同的类型，因此上题中 2）编译不通过。</description>
    </item>
    
    <item>
      <title>Go每日一题_068</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_068/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:51 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_068/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go每日一题_067</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_067/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:49 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_067/</guid>
      <description>下面代码输出什么？
type A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { c := Work{3} var a A = c var b B = c fmt.Println(a.ShowB()) fmt.Println(b.ShowA()) } A. 23 13 B. compilation error 🔑 答案解析：B 知识点：接口的静态类型。a、b 具有相同的动态类型和动态值，分别是结构体 work 和 {3}；a 的静态类型是 A，b 的静态类型是 B，接口 A 不包括方法 ShowB()，接口 B 也不包括方法 ShowA()，编译报错。.</description>
    </item>
    
    <item>
      <title>Go每日一题_066</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_066/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:48 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_066/</guid>
      <description>下面代码中 A B 两处应该怎么修改才能顺利编译？
func main() { var m map[string]int //A 	m[&amp;#34;a&amp;#34;] = 1 if v := m[&amp;#34;b&amp;#34;]; v != nil { //B 	fmt.Println(v) } } 🔑 答案解析：func main() { m := make(map[string]int) m[&amp;#34;a&amp;#34;] = 1 if v,ok := m[&amp;#34;b&amp;#34;]; ok { fmt.Println(v) } } 在 A 处只声明了map m ,并没有分配内存空间，不能直接赋值，需要使用 make()，都提倡使用 make() 或者字面量的方式直接初始化 map。
B 处，v,k := m[&amp;ldquo;b&amp;rdquo;] 当 key 为 b 的元素不存在的时候，v 会返回值类型对应的零值，k 返回 false。
.</description>
    </item>
    
    <item>
      <title>Go每日一题_065</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_065/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:47 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_065/</guid>
      <description>切片 a、b、c 的长度和容量分别是多少？
func main() { s := [3]int{1, 2, 3} a := s[:0] b := s[:2] c := s[1:2:cap(s)] } 🔑 答案解析：a len 0 cap 3 b len 2 cap 3 c len 1 cap 2
c 下表1 开始
参考答案及解析：a、b、c 的长度和容量分别是 0 3、2 3、1 2。
知识点：数组或切片的截取操作。截取操作有带 2 个或者 3 个参数，形如：[i:j] 和 [i:j:k]，假设截取对象的底层数组长度为 l。在操作符 [i:j] 中，如果 i 省略，默认 0，如果 j 省略，默认底层数组的长度，截取得到的切片长度和容量计算方法是 j-i、l-i。操作符 [i:j:k]，k 主要是用来限制切片的容量，但是不能大于数组的长度 l，截取得到的切片长度和容量计算方法是 j-i、k-i。
.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_064</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_064/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:46 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_064/</guid>
      <description>下面这段代码输出什么？
type A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { c := Work{3} var a A = c var b B = c fmt.Println(a.ShowA()) fmt.Println(b.ShowB()) } 🔑 答案解析：参考答案及解析：13 23。
知识点：接口。一种类型实现多个接口，结构体 Work 分别实现了接口 A、B，所以接口变量 a、b 调用各自的方法 ShowA() 和 ShowB()，输出 13、23。</description>
    </item>
    
    <item>
      <title>Go每日一题_063</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_063/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:45 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_063/</guid>
      <description>下面这段代码输出什么？
func main() { i := 65 fmt.Println(string(i)) } A. A B. 65 C. compilation error
🔑 答案解析：A UTF-8 编码中，十进制数字 65 对应的符号是 A。.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_062</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_062/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:44 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_062/</guid>
      <description>下面代码下划线处可以填入哪个选项？
func main() { var s1 []int var s2 = []int{} if __ == nil { fmt.Println(&amp;#34;yes nil&amp;#34;) }else{ fmt.Println(&amp;#34;no nil&amp;#34;) } }  A. s1 B. s2 C. s1、s2 都可以 🔑 答案解析：C s1 输出是yes nil s2 输出是no nil.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}  </description>
    </item>
    
    <item>
      <title>Go每日一题_061</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_061/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:42 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_061/</guid>
      <description>一次两道题，因为相关的。
1、以下代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { a := []int{2: 1} fmt.Println(a) } A：编译错误；B：[2 1]；C：[0 0 1]；D：[0 1]
2、以下代码输出什么？
package main func main() { var x = []int{4: 44, 55, 66, 1: 77, 88} println(len(x), x[2]) } A：5 66；B：5 88；C：7 88；D：以上都不对
🔑 答案解析：C C a := []int{2: 1} 下表2 值为1 因此初始化出来的切片 cap 3 len 3 内容是 0 0 1, int的零值为0 var x = []int{4: 44, 55, 66, 1: 77, 88} 这里要慢慢看 4: 44 下标4的值为44 ， 后面的55没有制定下标，默认是前一个+1 类似 5：55 ， 66就是 6:66， 1: 77 下标 1 值为 77 ，88 就是 2 ：88 因此初始化出来的切片 cap 7 len 7 内容是 0 77 88 0 44 55 66 [0 77 88 0 44 55 66].</description>
    </item>
    
    <item>
      <title>Go每日一题_060</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_060/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:41 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_060/</guid>
      <description>以下代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch1 := make(chan int) go fmt.Println(&amp;lt;-ch1) ch1 &amp;lt;- 5 time.Sleep(1 * time.Second) } A：5、B：不能编译；C：运行时死锁 🔑 答案解析：C 解析 因为 &amp;lt;-ch1 是个参数,可以理解为他要先取出来得到结果后再创建协程 因此运行时死锁。因修改成下方的形式
func main() { ch1 := make(chan int) go func() { fmt.Println(&amp;lt;-ch1) }() ch1 &amp;lt;- 5 time.Sleep(1 * time.Second) } 函数调用之前，实参就被求值好了 .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_059</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_059/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:40 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_059/</guid>
      <description>对 add() 函数调用正确的是？
func add(args ...int) int { sum := 0 for _, arg := range args { sum += arg } return sum } A. add(1, 2) B. add(1, 3, 7) C. add([]int{1, 2}) D. add([]int{1, 3, 7}&amp;hellip;) 🔑 答案解析：答 ABD
虽然 &amp;hellip; 本质上也是个 切片 但是不能使用C这种方式
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_058</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_058/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:39 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_058/</guid>
      <description>下面代码输出什么？
func incr(p *int) int { *p++ return *p } func main() { p :=1 incr(&amp;amp;p) fmt.Println(p) } A. 1 B. 2 C. 3 🔑 答案解析：答案：B。
知识点：指针，incr() 函数里的 p 是 *int 类型的指针，指向的是 main() 函数的变量 p 的地址。 第 2 行代码是将该地址的值执行一个自增操作，incr() 返回自增后的结果。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_057</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_057/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:38 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_057/</guid>
      <description>下列选项正确的是？
func main() { str := &amp;#34;hello&amp;#34; str[0] = &amp;#39;x&amp;#39; fmt.Println(str) } A. hello B. xello C. compilation error 🔑 答案解析：参考代码及解析：C。
知识点：Go 语言中的字符串是只读的。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_056</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_056/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:36 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_056/</guid>
      <description>下面这段代码输出什么？
type People struct{} func (p *People) ShowA() { fmt.Println(&amp;#34;showA&amp;#34;) p.ShowB() } func (p *People) ShowB() { fmt.Println(&amp;#34;showB&amp;#34;) } type Teacher struct { People } func (t *Teacher) ShowB() { fmt.Println(&amp;#34;teacher showB&amp;#34;) } func main() { t := Teacher{} t.ShowA() } 🔑 答案解析：答 &amp;ldquo;showA&amp;rdquo; &amp;ldquo;showB&amp;rdquo;
t.ShowA() 会优先调用t自己的ShowA，但是题中未定义着调用父 struct的showA。运行到p.ShowB()时，这里注意是p *People p是父 struct，他会调用p自己的ShowB 因此输出 &amp;ldquo;showA&amp;rdquo; &amp;ldquo;showB&amp;rdquo;
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_055</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_055/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:35 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_055/</guid>
      <description>下面这段代码输出什么?
func hello(i int) { fmt.Println(i) } func main() { i := 5 defer hello(i) i = i + 10 } 🔑 答案解析：答 5 hello() 函数的参数在执行 defer 语句的时候会保存一份副本，在实际调用 hello() 函数时用，所以是 5.
&amp;gt;Golang中的Defer必掌握的7知识点
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_054</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_054/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:34 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_054/</guid>
      <description>以下代码输出什么？
package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { t := struct { time.Time N int }{ time.Date(2020, 12, 20, 0, 0, 0, 0, time.UTC), 5, } m, _ := json.Marshal(t) fmt.Printf(&amp;#34;%s&amp;#34;, m) } A：{&amp;ldquo;Time&amp;rdquo;: &amp;ldquo;2020-12-20T00:00:00Z&amp;rdquo;, &amp;ldquo;N&amp;rdquo;: 5 }；B：&amp;ldquo;2020-12-20T00:00:00Z&amp;rdquo;；C：{&amp;ldquo;N&amp;rdquo;: 5}；D：&amp;lt;nil&amp;gt;
🔑 答案解析：答 B 题中time.Time 是内嵌到匿名struct 中的，也就是继承了time.Time 。 time.Time 的重写了MarshalJSON 方法因此会按照time.Time 的MarshalJSON 规定的格式输出.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_053</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_053/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:33 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_053/</guid>
      <description>定义一个包内全局字符串变量，下面语法正确的是（多选）：
A. var str string B. str := &amp;quot;&amp;quot; C. str = &amp;quot;&amp;quot; D. var str = &amp;quot;&amp;quot;
🔑 答案解析：A D 关键在 包内全局 B := 只能用到函数没 C 是赋值并不是声明.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_052</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_052/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:31 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_052/</guid>
      <description>下面这段代码输出什么？
type People struct{} func (p *People) ShowA() { fmt.Println(&amp;#34;showA&amp;#34;) p.ShowB() } func (p *People) ShowB() { fmt.Println(&amp;#34;showB&amp;#34;) } type Teacher struct { People } func (t *Teacher) ShowB() { fmt.Println(&amp;#34;teacher showB&amp;#34;) } func main() { t := Teacher{} t.ShowB() } 🔑 答案解析：答 ：teacher showB t.ShowB() 会使用自己已有的ShowB() ， 若要使用父struct（People）的ShowB() 需要改为 t.People.ShowB().toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_051</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_051/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:30 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_051/</guid>
      <description>下面这段代码输出什么？
func main() { i := -5 j := +5 fmt.Printf(&amp;#34;%+d %+d&amp;#34;, i, j) } A. -5 +5 B. +5 +5 C. 0 0 🔑 答案解析：A %d表示输出十进制数字，+表示输出数值的符号。这里不表示取反。 %d 输出 正数不会输出符号 +.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_050</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_050/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:29 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_050/</guid>
      <description>下面这段代码输出什么？
func main() { s := make(map[string]int) delete(s, &amp;#34;h&amp;#34;) fmt.Println(s[&amp;#34;h&amp;#34;]) } A. runtime panic B. 0 C. compilation error 🔑 答案解析：B 0 delete 一个不存在的key并不会panic 输出一个不存在的key会输出类型的零值
扩展
func main() { var s map[string]int delete(s, &amp;#34;h&amp;#34;) s[&amp;#34;h&amp;#34;] = 1 fmt.Println(s[&amp;#34;h&amp;#34;]) } delete nil map 程序也不会panic 但是往nil map 写数据会panic
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_049</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_049/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:28 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_049/</guid>
      <description>下面这段代码输出什么？
func main() { var i interface{} if i == nil { fmt.Println(&amp;#34;nil&amp;#34;) return } fmt.Println(&amp;#34;not nil&amp;#34;) } A. nil B. not nil C. compilation error
🔑 答案解析：A 接口类型 当动态值和动态类型都为 nil 时，接口类型值才为 nil。.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_048</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_048/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:27 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_048/</guid>
      <description>以下哪种类型可以使用 cap() 函数？
A. array B. slice C. map D. channel
🔑 答案解析：ABD 数组 切片 管道.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_047</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_047/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:26 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_047/</guid>
      <description>下面这段代码输出什么？
func main() { a := [2]int{5, 6} b := [3]int{5, 6} if a == b { fmt.Println(&amp;#34;equal&amp;#34;) } else { fmt.Println(&amp;#34;not equal&amp;#34;) } } A. compilation error B. equal C. not equal 🔑 答案解析：A 只有同容量，同类型的数组才能比较.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_046</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_046/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:24 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_046/</guid>
      <description>下面这段代码输出什么？
package main import ( &amp;#34;fmt&amp;#34; ) func main() { a := [5]int{1, 2, 3, 4, 5} t := a[3:4:4] fmt.Println(t[0]) } A.3 B.4 C.compilation error 🔑 答案解析：答B 解析 t := a[3:4:4] 基于a切片生成一个新切片t ,该t的起始指向a[3]的位置,到a[4]停止.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_045</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_045/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:23 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_045/</guid>
      <description>以下代码能否通过编译？
package main import ( &amp;#34;fmt&amp;#34; ) type worker interface { work() } type person struct { name string worker } func main() { var w worker = person{} fmt.Println(w) } A: 能；B: 不能；C: 不知道
🔑 答案解析：A
Go结构体中是可以嵌套接口类型的
嵌入接口有实际用途。 例：标准库中 sort 包中，有一个接口：Interface
type Interface interface { // Len is the number of elements in the collection. 	Len() int // Less reports whether the element with 	// index i should sort before the element with index j.</description>
    </item>
    
    <item>
      <title>Go每日一题_044</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_044/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:22 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_044/</guid>
      <description>以下代码有什么问题，怎么解决？
total, sum := 0, 0 for i := 1; i &amp;lt;= 10; i++ { sum += i go func() { total += i }() } fmt.Printf(&amp;#34;total:%d sum %d&amp;#34;, total, sum) 🔑 答案解析：sum 的值 55 total 的值 55 - 100 之前
考点一： 知道输出的效果是什么，且知道如何解决。 考点二： data race。因为存在多 goroutine 同时写 total 变量的问题，所以有数据竞争。 考点三： main 函数先退出了，开启的 goroutine 根本没有机会执行。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_043</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_043/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:21 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_043/</guid>
      <description>以下代码输出什么？
package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; ) type AutoGenerated struct { Age int `json:&amp;#34;age&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Child []int `json:&amp;#34;child&amp;#34;` } func main() { jsonStr1 := `{&amp;#34;age&amp;#34;: 14,&amp;#34;name&amp;#34;: &amp;#34;potter&amp;#34;, &amp;#34;child&amp;#34;:[1,2,3]}` a := AutoGenerated{} json.Unmarshal([]byte(jsonStr1), &amp;amp;a) aa := a.Child fmt.Println(aa) jsonStr2 := `{&amp;#34;age&amp;#34;: 12,&amp;#34;name&amp;#34;: &amp;#34;potter&amp;#34;, &amp;#34;child&amp;#34;:[3,4,5,7,8,9]}` json.Unmarshal([]byte(jsonStr2), &amp;amp;a) fmt.Println(aa) } A：[1 2 3] [1 2 3] ； B：[1 2 3] [3 4 5]； C：[1 2 3] [3 4 5 6 7 8 9]； D：[1 2 3] [3 4 5 0 0 0]</description>
    </item>
    
    <item>
      <title>Go每日一题_042</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_042/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:20 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_042/</guid>
      <description>下面这段代码输出什么？
func main() { a := 5 b := 8.1 fmt.Println(a + b) } A.13.1 B.13 C.compilation error
🔑 答案解析：参考答案及解析：C。a 的类型是 int，b 的类型是 float，两个不同类型的数值不能相加，编译报错。.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_041</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_041/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:18 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_041/</guid>
      <description>下面这段代码输出什么？
func hello(num ...int) { num[0] = 18 } func main() { i := []int{5, 6, 7} hello(i...) fmt.Println(i[0]) } A.18 B.5 C.Compilation error 🔑 答案解析：答： A 18 解析：&amp;hellip; 变质是传切片，又因为未发生切片扩容，因此这2个切片指的底层数组是同一个。因此i[0]被改为18
这里对原题目做出小改动
package main import &amp;#34;fmt&amp;#34; func hello(num ...int) { num = append(num, 1) num[0] = 18 } func main() { i := []int{5, 6, 7} hello(i...) fmt.Println(i[0]) } 改动后 num的切片发送了扩容，导致2个切片指的底层数组不通，因此不会影响到 i切片 最终print 输出 5
.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_040</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_040/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:17 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_040/</guid>
      <description>下面这段代码输出什么？
type person struct { name string } func main() { var m map[person]int p := person{&amp;#34;mike&amp;#34;} fmt.Println(m[p]) } A.0 B.1 C.Compilation error 🔑 答案解析：答 ：A 0
m 是一个 map，值是 nil。从 nil map 中取值不会报错，而是返回相应的零值，这里值是 int 类型，因此返回 0。
注意 ： nil map是可以取值，但是不能赋值。会导致程序panic的
package main import &amp;#34;fmt&amp;#34; type person struct { name string } func main() { var m map[person]int p := person{&amp;#34;mike&amp;#34;} m[p] = 2 fmt.Println(m[p]) } 运行结果：panic: assignment to entry in nil map</description>
    </item>
    
    <item>
      <title>Go每日一题_039</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_039/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:16 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_039/</guid>
      <description>关于 channel，下面语法正确的是：
A. var ch chan int B. ch := make(chan int) C. &amp;lt;- ch D. ch &amp;lt;- 🔑 答案解析：答：ABC
A、B 都是声明 channel；C 读取 channel； 写 channel 是必须带上值，所以 D 错误。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_038</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_038/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:15 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_038/</guid>
      <description>以下代码有什么问题？
package main import ( &amp;#34;sync&amp;#34; ) const N = 10 var wg = &amp;amp;sync.WaitGroup{} func main() { for i := 0; i &amp;lt; N; i++ { go func(i int) { wg.Add(1) println(i) defer wg.Done() }(i) } wg.Wait() } 🔑 答案解析：答：输出结果不唯一，代码存在风险, 所有 go 语句未必都能执行到。 解析：
var wg = &amp;amp;sync.WaitGroup{} wg.Add(1) wg.Done() wg.Wait() 该用法类似一个栈,wg.Wait()判断wg中是否还有记录有的话堵塞直到栈为0才开始活跃。 这里的写法存在问题。wg.Add(1)被放到了协程中，导致存在未运行wg.Add(1)，wg.Wait()就已经判断结束了。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_037</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_037/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:14 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_037/</guid>
      <description>执行下面的代码会发生什么？
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch := make(chan int, 1000) go func() { for i := 0; i &amp;lt; 10; i++ { ch &amp;lt;- i } }() go func() { for { a, ok := &amp;lt;-ch if !ok { fmt.Println(&amp;#34;close&amp;#34;) return } fmt.Println(&amp;#34;a: &amp;#34;, a) } }() close(ch) fmt.Println(&amp;#34;ok&amp;#34;) time.Sleep(time.Second * 100) } 🔑 答案解析：答 输出&amp;quot;ok&amp;quot;后panic 启动协程需要时间,这里程序运行close(ch)一句关闭channel了,往已关闭的channel写数据会导致程序panic.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_036</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_036/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:12 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_036/</guid>
      <description>下面这段代码能否编译通过？如果可以，输出什么？
func GetValue() int { return 1 } func main() { i := GetValue() switch i.(type) { case int: println(&amp;#34;int&amp;#34;) case string: println(&amp;#34;string&amp;#34;) case interface{}: println(&amp;#34;interface&amp;#34;) default: println(&amp;#34;unknown&amp;#34;) } } 🔑 答案解析：答 编译错误 这里使用到了 类型断言。 但是注意只有接口类型才能进行类型断言。 i.(type)，这里i 的类型是 int 而不是 接口.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_035</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_035/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:11 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_035/</guid>
      <description>下面这段代码输出什么以及原因？
func hello() []string { return nil } func main() { h := hello if h == nil { fmt.Println(&amp;#34;nil&amp;#34;) } else { fmt.Println(&amp;#34;not nil&amp;#34;) } } A. nil B. not nil C. compilation error
🔑 答案解析：B。这道题目里面，是将函数 hello 赋值给变量 h，而不是函数的返回值（即不是进行函数调用），所以输出 not nil。注意 Go 中函数是一等公民。
如果修改为
func hello() []string { return nil } func main() { h := hello() if h == nil { fmt.Println(&amp;#34;nil&amp;#34;) } else { fmt.Println(&amp;#34;not nil&amp;#34;) } } 答案才能为A</description>
    </item>
    
    <item>
      <title>Go每日一题_034</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_034/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:10 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_034/</guid>
      <description>关于 init 函数，下面说法正确的是：(多选)
A. 一个包中，可以包含多个 init 函数； B. 程序运行时，先执行依赖包的 init 函数，再执行 main 包内的 init 函数； C. main 包中，不能有 init 函数； D. init 函数可以被其他函数调用；
🔑 答案解析：答案是AB.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_033</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_033/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:09 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_033/</guid>
      <description>今天给两道类似的题目，注意，有半数以上的人可能会做错！
package main func main() { var a int8 = -1 var b int8 = -128 / a println(b) } package main func main() { const a int8 = -1 var b int8 = -128 / a println(b) } 🔑 答案解析：题一： 因为 var b int8 = -128 / a 不是常量表达式，因此 untyped 常量 -128 隐式转换为 int8 类型（即和 a 的类型一致），所以 -128 / a 的结果是 int8 类型，值是 128，超出了 int8 的范围。因为结果不是常量，允许溢出，128 的二进制表示是 10000000，正好是 -128 的补码。所以，第一题的结果是 -128。 题二： -128 和 -1 都是 const，直接在编译时求值，untyped 的 -128 隐式转 int8，结果为 128，仍然是一个 const。const 转换时不允许溢出，编译错误。 其实差别就是表达式的值，题一不是常量题二是，常量类型转换不允许溢出后 truncate。.</description>
    </item>
    
    <item>
      <title>Go每日一题_032</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_032/</link>
      <pubDate>Fri, 06 Dec 2024 20:44:08 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_032/</guid>
      <description>以下代码能通过编译吗？为什么？
package main import ( &amp;#34;fmt&amp;#34; ) type People interface { Speak(string) string } type Student struct{} func (stu *Student) Speak(think string) (talk string) { if think == &amp;#34;love&amp;#34; { talk = &amp;#34;You are a good boy&amp;#34; } else { talk = &amp;#34;hi&amp;#34; } return } func main() { var peo People = Student{} think := &amp;#34;love&amp;#34; fmt.Println(peo.Speak(think)) } 🔑 答案解析：不能,应为是*Student 实现了People接口的方法。 而现在是Student 赋值给People接口类型。因此编译错误 需要修改为
var peo People = &amp;amp;Student{} .</description>
    </item>
    
    <item>
      <title>Go每日一题_022</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_022/</link>
      <pubDate>Fri, 06 Dec 2024 19:49:56 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_022/</guid>
      <description>下面这段代码能否通过编译，如果可以，输出什么？
package main var( size := 1024 max_size = size*2 ) func main() { fmt.Println(size,max_size) } 🔑 答案解析：答：不能
var( size := 1024 ) 不符合规范 问题1：var 声明变量不能使用 := 问题2: := 只能在函数内使用，本题在声明全局变量中使用 参考解析：这道题的主要知识点是变量声明的简短模式，形如：x := 100.
但这种声明方式有限制：  必须使用显示初始化； 不能提供数据类型，编译器会自动推导； 只能在函数内部使用简短模式；  .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_023</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_023/</link>
      <pubDate>Fri, 06 Dec 2024 19:49:56 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_023/</guid>
      <description>通过指针变量 p 访问其成员变量 name，有哪几种方式？（多选）
A.p.nameB.(&amp;amp;p).nameC.(*p).nameD.p-&amp;gt;name🔑 答案解析：答: AC &amp;amp; 取址运算符，* 指针解引用。 p 是指针变量, 因此可以使用 *指针解引用 Go有语法糖,直接使用 指针变量.成员变量 也是可以访问的.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_024</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_024/</link>
      <pubDate>Fri, 06 Dec 2024 19:49:56 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_024/</guid>
      <description>下面这段代码能否通过编译？如果通过，输出什么？
package main import &amp;#34;fmt&amp;#34; type MyInt1 int type MyInt2 = int func main() { var i int =0 var i1 MyInt1 = i var i2 MyInt2 = i fmt.Println(i1,i2) } 🔑 答案解析：答: 不能 参考解析：这道题考的是类型别名与类型定义的区别。 类型别名type MyInt2 = int 类型定义type MyInt1 int Go 赋值 = 左右的类型需要一致。 MyInt1 是基于int定义的新类型,因此不能直接赋值。如果需要赋值，需要类型转换	var i1 MyInt1 = MyInt1(i) .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_025</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_025/</link>
      <pubDate>Fri, 06 Dec 2024 19:49:56 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_025/</guid>
      <description>关于字符串连接，下面语法正确的是？
A. str := &#39;abc&#39; + &#39;123&#39;B. str := &amp;quot;abc&amp;quot; + &amp;quot;123&amp;quot;C. str := &#39;123&#39; + &amp;quot;abc&amp;quot;D. fmt.Sprintf(&amp;quot;abc%d&amp;quot;, 123)🔑 答案解析：答：BD &#39; &#39; 只能用于单字符 因此AC都无法通过编译
字符串链接推荐使用 buffer.WriteString()
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_026</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_026/</link>
      <pubDate>Fri, 06 Dec 2024 19:49:56 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_026/</guid>
      <description>以下代码能否编译？
package main import &amp;#34;fmt&amp;#34; type Student struct { Name string } var list map[string]Student func main() { list = make(map[string]Student) student := Student{&amp;#34;Aceld&amp;#34;} list[&amp;#34;student&amp;#34;] = student list[&amp;#34;student&amp;#34;].Name = &amp;#34;LDB&amp;#34; fmt.Println(list[&amp;#34;student&amp;#34;]) } 🔑 答案解析：答：编译失败。 map[string]Student 的 value 是一个 Student 结构值，所以当list[&amp;quot;student&amp;quot;] = student,是一个值拷贝过程。而list[&amp;ldquo;student&amp;rdquo;]则是一个值引用。那么值引用的特点是只读。所以对list[&amp;ldquo;student&amp;rdquo;].Name = &amp;ldquo;LDB&amp;quot;的修改是不允许的。
如果真要修改需要New一个新的结构体，修改内容后重新赋值
//list[&amp;#34;student&amp;#34;].Name = &amp;#34;LDB&amp;#34; 	newStudent := list[&amp;#34;student&amp;#34;] newStudent.Name = &amp;#34;LDB&amp;#34; list[&amp;#34;student&amp;#34;] = newStudent 或者将map value 改为一个 Student 结构值指针 map[string]*Student
package main import &amp;#34;fmt&amp;#34; type Student struct { Name string } var list map[string]*Student func main() { list = make(map[string]*Student) student := Student{&amp;#34;Aceld&amp;#34;} list[&amp;#34;student&amp;#34;] = &amp;amp;student list[&amp;#34;student&amp;#34;].</description>
    </item>
    
    <item>
      <title>Go每日一题_027</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_027/</link>
      <pubDate>Fri, 06 Dec 2024 19:49:55 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_027/</guid>
      <description>以下代码有什么问题，说明原因
package main import ( &amp;#34;fmt&amp;#34; ) type student struct { Name string Age int } func main() { //定义map  m := make(map[string]*student) //定义student数组  stus := []student{ {Name: &amp;#34;zhou&amp;#34;, Age: 24}, {Name: &amp;#34;li&amp;#34;, Age: 23}, {Name: &amp;#34;wang&amp;#34;, Age: 22}, } //将数组依次添加到map中  for _, stu := range stus { m[stu.Name] = &amp;amp;stu } //打印map  for k,v := range m { fmt.Println(k ,&amp;#34;=&amp;gt;&amp;#34;, v.Name) } } 🔑 答案解析：注意此类问题在Go版本在1.</description>
    </item>
    
    <item>
      <title>Go每日一题_028</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_028/</link>
      <pubDate>Fri, 06 Dec 2024 19:49:55 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_028/</guid>
      <description>下面这段代码能否编译通过？如果可以，输出什么？
const ( x = iota _ y z = &amp;#34;zz&amp;#34; k p = iota ) func main() { fmt.Println(x,y,z,k,p) } 🔑 答案解析：参考答案：编译通过，输出：0 2 zz zz 5
const 定义的时候 若变量后未跟随值将会沿用上一个变量的值
const ( x = iota _ = iota y = iota z = &amp;#34;zz&amp;#34; k = &amp;#34;zz&amp;#34; p = iota ) iota 相当于const语句块的行索引
const ( x = 0 _ = 1 y = 2 z = &amp;#34;zz&amp;#34; k = &amp;#34;zz&amp;#34; p = 5 ) .</description>
    </item>
    
    <item>
      <title>Go每日一题_029</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_029/</link>
      <pubDate>Fri, 06 Dec 2024 19:49:55 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_029/</guid>
      <description>下面赋值正确的是：
A. var x = nil B. var x interface{} = nil C. var x string = nil D. var x error = nil
🔑 答案解析：BD。这道题考的知识点是 nil。nil 只能赋值给指针
A 未指定类型 B 空接口 可以赋值nil C 字符串本质是个只读切片 不可以赋值nil D error 本质是个接口类型 可以赋值nil
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_021</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_021/</link>
      <pubDate>Fri, 06 Dec 2024 19:47:08 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_021/</guid>
      <description>写出程序运行的结果：
package main import ( &amp;#34;fmt&amp;#34; ) func main(){ s := make([]int, 10) s = append(s, 1, 2, 3) fmt.Println(s) } 🔑 答案解析：答： [0 0 0 0 0 0 0 0 0 0 1 2 3] make( 类型 , cap , len) 若只填写 cap, 则 len = cap 因此 s := make([]int, 10) s 切片的值 [0 0 0 0 0 0 0 0 0 0].toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title>Go每日一题_001</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_001/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:54 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_001/</guid>
      <description>下面这段代码输出什么，说明原因。
func main() { slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { m[key] = &amp;amp;val } for k,v := range m { fmt.Println(k,&amp;#34;-&amp;gt;&amp;#34;,*v) } } 🔑 答案解析：注意此类问题在Go版本在1.22 版本后将会有变化 🔗:修复 Go 1.22 中的 For 循环
 Go &amp;gt;=1.22
 0 -&amp;gt; 0 1 -&amp;gt; 1 2 -&amp;gt; 2 3 -&amp;gt; 3 解释：Go &amp;lt;= 1.22 当 for key,val := range slice 时,每次循环都会创建新变量 key、val。从而实现每次循环的 key、val变量的地址都是不同的。
在源代码上增加验证打印
package main import &amp;#34;fmt&amp;#34; func main() { slice := []int{0, 1, 2, 3} m := make(map[int]*int) for key, val := range slice { m[key] = &amp;amp;val fmt.</description>
    </item>
    
    <item>
      <title>Go每日一题_002</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_002/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:53 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_002/</guid>
      <description>下面这段代码输出的内容
package main import ( &amp;#34;fmt&amp;#34; ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(&amp;#34;打印前&amp;#34;) }() defer func() { fmt.Println(&amp;#34;打印中&amp;#34;) }() defer func() { fmt.Println(&amp;#34;打印后&amp;#34;) }() panic(&amp;#34;触发异常&amp;#34;) } 🔑 答案解析：打印后打印中打印前panic: 触发异常解析：defer 的执行顺序是后进先出。当出现 panic 语句的时候，会先按照 defer 的后进先出的顺序执行，最后才会执行panic。
知识点:defer后进先出
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_003</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_003/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:53 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_003/</guid>
      <description>map 的 key 为什么是无序的？
在遍历 map 的时候，我们会发现，输出的 key 是无序的。为什么？
🔑 答案解析：在go &amp;lt;= 1.0 以后 迭代 map 的结果是无序的。 这是Golang map的实现原理导致的。在扩容中Map会指向新的桶，这是并不会立刻全部迁移，而是会指向新桶和旧桶。遍历Map上本质遍历这2个桶。但是发生了扩容Key的位置改变导致遍历的结果不同。 在go &amp;gt; 1.0 以前遍历Map的时候 不扩容时是有序的，扩容后将改变顺序。为了统一这个问题go&amp;gt;=1.0加入了遍历Map会随机播种，使得遍历无序。
参考资料：
 🔗:key为什么是无序的 🔗:为什么遍历 Go map 是无序的(源码分析)  .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_006</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_006/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:53 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_006/</guid>
      <description>下面这段代码有什么缺陷：
func sum(x, y int)(total int, error) { return x+y, nil } 🔑 答案解析：答案:(total int, error) 第二个返回值error没有命名
解析: 在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。 func sum(x, y int)(total int,err error) {如果有多个返回值必须加上括号()； func sum(x, y int)(total int,err error) func sum(x, y int)int如果只有一个返回值且命名也必须加上括号()。func sum(x, y int)(total int) {
这里的第一个返回值有命名 total，第二个没有命名，所以错误。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_007</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_007/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_007/</guid>
      <description>以下代码是否能编译通过？
package main import &amp;#34;fmt&amp;#34; func main() { m := make(map[string]int) fmt.Println(&amp;amp;m[&amp;#34;qcrao&amp;#34;]) } 🔑 答案解析：答:不能,编译报错
 .\main.go:8:15: invalid operation: cannot take address of m[&amp;ldquo;qcrao&amp;rdquo;] (map index expression of type int)
 解析: 这个问题，相当于问：可以对 map 的元素直接取地址吗？
知识点:无法直接对 map 的 key 或 value 进行取址。如果通过其他 hack 的方式，例如 unsafe.Pointer 等获取到了 key 或 value 的地址，也不能长期持有，因为一旦发生扩容，key 和 value 的位置就会改变，之前保存的地址也就失效了。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_008</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_008/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_008/</guid>
      <description>以下代码是否能编译通过？
如何确认两个 map 是否相等？ 🔑 答案解析：map 深度相等的条件：
都为 nil 非空、长度相等，指向同一个 map 实体对象 相应的 key 指向的 value “深度”相等
直接将使用 map1 == map2 是错误的。这种写法只能比较 map 是否为 nil。
package main import &amp;#34;fmt&amp;#34; func main() { var m map[string]int var n map[string]int fmt.Println(m == nil) fmt.Println(n == nil) // 不能通过编译 	//fmt.Println(m == n) } 方案一: 遍历（比较麻烦） 遍历 map 的每个元素，比较元素是否都是深度相等。 方案二: 反射
package main import( &amp;#34;fmt&amp;#34; &amp;#34;relflect&amp;#34; ) func main() { var m map[string]int var n map[string]int fmt.</description>
    </item>
    
    <item>
      <title>Go每日一题_009</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_009/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_009/</guid>
      <description>空 struct{} 占多少空间？有什么用途？
🔑 答案解析：答:0 , 用于占位符
例如:
 map[string]struct{},只关注key是否存在的话可以使用节省内存空间 ch := make(chan struct{}, 1)，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。 type Lamp struct{} ,声明只包含方法的结构体。  type Lamp struct{} func (l Lamp) On() { println(&amp;#34;On&amp;#34;) } func (l Lamp) Off() { println(&amp;#34;Off&amp;#34;) } 解析: Go为每一种类型都有全局唯一的类型元数据，元数据记录了该类型大小。因为空结构体内没有任何的类型因此空类型的大小为0。但是因为有创建类型元数据因此可以想正常的类型一样用于占位 这里建议看一下参考资料【幼麟实验室】- Go类型系统讲解
参考资料：
 🔗📺️:【幼麟实验室】- Go类型系统讲解  .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_010</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_010/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_010/</guid>
      <description>init() 函数是什么时候执行的？
🔑 答案解析：答:init()是再main()函数执行前
一句话总结： import –&amp;gt; const –&amp;gt; var –&amp;gt; init() –&amp;gt; main()
如果有多个init就要分情况
 单个源文件的 init 执行顺序  结论： 同一个源文件的 init 函数执行顺序与其定义顺序一致，从上到下。
package main func init() { println(&amp;#34;init a&amp;#34;) } func init() { println(&amp;#34;init b&amp;#34;) } func init() { println(&amp;#34;init c&amp;#34;) } func main() { println(&amp;#34;main&amp;#34;) } $ go run main.go init a init b init c main 单个包的 init 执行顺序  结论： 同一个包中不同源文件 init 函数的执行顺序，是根据文件名的字典序来确定。
// a.</description>
    </item>
    
    <item>
      <title>Go每日一题_011</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_011/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_011/</guid>
      <description>new() 与 make() 的区别
🔑 答案解析：new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。
make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel。
参考资料:
 🔗📺️:【Golang】slice类型存什么？make和new？slice和数组？扩容规则  .toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_012</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_012/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_012/</guid>
      <description>下面这段代码能否通过编译，不能的话原因是什么；如果通过，输出什么。
func main() { list := new([]int) list = append(list, 1) fmt.Println(list) } 🔑 答案解析：不能通过编译，new([]int) 之后的 list 是一个 *[]int 类型的指针，不能对指针执行 append 操作。可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_013</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_013/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:51 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_013/</guid>
      <description>下面这段代码能否通过编译，如果可以，输出什么？
func main() { s1 := []int{1, 2, 3} s2 := []int{4, 5} s1 = append(s1, s2) fmt.Println(s1) } 🔑 答案解析：不能通过编译。append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_014</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_014/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:51 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_014/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go每日一题_015</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_015/</link>
      <pubDate>Fri, 06 Dec 2024 19:40:51 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_015/</guid>
      <description>Go 1.15 中 var i interface{} = a 会有额外堆内存分配吗？ 具体代码是：
var a int = 3 // 以下有额外内存分配吗？ var i interface{} = a 🔑 答案解析：正确答案:不会
解析: *Go 1.15 发行说明**在 runtime 部分中提到了一个有趣的改进：
 Converting a small integer value into an interface value no longer causes allocation.
 意思是说，将小整数转换为接口值不再需要进行内存分配。小整数是指 0 到 255 之间的数。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_016</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_016/</link>
      <pubDate>Fri, 06 Dec 2024 18:35:20 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_016/</guid>
      <description>Go101 作者发布了一道有意思的题目，这道题主要考察细节点，Go101 这本书也是以抠细节著称。看看这道题，以下程序输出什么？（单选）
package main const s = &amp;#34;Go101.org&amp;#34; // len(s) == 9 // 1 &amp;lt;&amp;lt; 9 == 512 // 512 / 128 == 4  var a byte = 1 &amp;lt;&amp;lt; len(s) / 128 var b byte = 1 &amp;lt;&amp;lt; len(s[:]) / 128 func main() { println(a, b) } A、0 0；B、0 4；C：4 0；D：4 4
🔑 答案解析：这里共有2个知识点：
 len(s)   若s为字符串常量或者简单的数组表达式，则len返回的为int型的常量 若s为不为上述情况（有函数计算、通道等），则len返回的为int型的变量  关于位移操作   如果常量位移表达式 的左侧操作数是一个无类型常量，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量（必须是 整数类型 ） 如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型  回到题目.</description>
    </item>
    
    <item>
      <title>Go每日一题_017</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_017/</link>
      <pubDate>Fri, 06 Dec 2024 18:34:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_017/</guid>
      <description>下面代码是否可以编译通过？为什么？
package main import &amp;#34;fmt&amp;#34; func main() { sn1 := struct { age int name string }{age: 11, name: &amp;#34;qq&amp;#34;} sn2 := struct { age int name string }{age: 11, name: &amp;#34;qq&amp;#34;} if sn1 == sn2 { fmt.Println(&amp;#34;sn1 == sn2&amp;#34;) } sm1 := struct { age int m map[string]string }{age: 11, m: map[string]string{&amp;#34;a&amp;#34;: &amp;#34;1&amp;#34;}} sm2 := struct { age int m map[string]string }{age: 11, m: map[string]string{&amp;#34;a&amp;#34;: &amp;#34;1&amp;#34;}} if sm1 == sm2 { fmt.</description>
    </item>
    
    <item>
      <title>Go每日一题_018</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_018/</link>
      <pubDate>Fri, 06 Dec 2024 18:34:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_018/</guid>
      <description>下面代码有什么问题？
package main const cl = 100 var bl = 123 func main() { println(&amp;amp;bl,bl) println(&amp;amp;cl,cl) } 🔑 答案解析：答: 编译不通过。 cl为 常量。常量无法获取地址.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_019</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_019/</link>
      <pubDate>Fri, 06 Dec 2024 18:34:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_019/</guid>
      <description>下面这段代码能否通过编译，不能的话原因是什么；如果通过，输出什么。
func main() { list := new([]int) list = append(list, 1) fmt.Println(list) } 🔑 答案解析：答: 无法通过编译。 list的类型是 *[]int 类型的指针。 append 第一个参数的类型是切片，不能为切片的地址
可以使用 make() 初始化之后再用。同样的，map 和 channel 建议使用 make() 或字面量的方式初始化，不要用 new() 。
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_020</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_020/</link>
      <pubDate>Fri, 06 Dec 2024 18:34:52 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_020/</guid>
      <description>下面这段代码能否通过编译，如果可以，输出什么？
func main() { s1 := []int{1, 2, 3} s2 := []int{4, 5} s1 = append(s1, s2) fmt.Println(s1) } 🔑 答案解析：答: 无法通过编译。 append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_005</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_005/</link>
      <pubDate>Fri, 05 Jan 2024 00:00:00 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_005/</guid>
      <description>Go 的 map 可以边遍历边删除吗？
🔑 答案解析：答：理论上可以。 https://go.dev/doc/effective_go#for ， 这个官方例子也展示了可以在遍历的时候删除。 https://go.dev/ref/spec#For_statements ， 同时官方的range迭代也有说着遍历时删除和新增的情况
但是清注意 map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。 并发的去读写map是十分危险的,建议直接用m=make(map[T]T)生成新的map对象,老的map让GC自动回收内存空间
.toggle-content {display: none;margin-top: 10px;}.toggle-content.show {display: block;}</description>
    </item>
    
    <item>
      <title>Go每日一题_004</title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_004/</link>
      <pubDate>Thu, 04 Jan 2024 00:00:00 +0800</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_004/</guid>
      <description>下面两段代码输出什么。
// 1. func main() { s := make([]int, 5) s = append(s, 1, 2, 3) fmt.Println(s) } // 2. func main() { s := make([]int,0) s = append(s,1,2,3,4) fmt.Println(s) } 🔑 答案解析：// 1[0 0 0 0 0 1 2 3]// 2[1 2 3 4]解析: 首先了解一下切片的结构。
// runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 	len int // 长度 	cap int // 容量 }  slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。</description>
    </item>
    
    <item>
      <title></title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_030/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_030/</guid>
      <description>以下代码能通过编译吗？为什么？
package main import ( &amp;#34;fmt&amp;#34; ) type People interface { Speak(string) string } type Student struct{} func (stu *Student) Speak(think string) (talk string) { if think == &amp;#34;love&amp;#34; { talk = &amp;#34;You are a good boy&amp;#34; } else { talk = &amp;#34;hi&amp;#34; } return } func main() { var peo People = Student{} think := &amp;#34;love&amp;#34; fmt.Println(peo.Speak(think)) } 🔑 答案解析：编译不通过，因为 是*Student重写interface的接口 而不是Student。.toggle-content {display: none;margin-top: 10px;}.</description>
    </item>
    
    <item>
      <title></title>
      <link>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_031/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/go_practise/data/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98_031/</guid>
      <description>以下代码打印出来什么内容，说出为什么。
package main import ( &amp;#34;fmt&amp;#34; ) type People interface { Show() } type Student struct{} func (stu *Student) Show() { } func live() People { var stu *Student return stu } func main() { if live() == nil { fmt.Println(&amp;#34;AAAAAAA&amp;#34;) } else { fmt.Println(&amp;#34;BBBBBBB&amp;#34;) } } 🔑 答案解析：输出的是BBBBBBB 简单解释一下，就是接口的底层其实是有2个指针 一个指向类型,一个指向值。
//伪代码指针{类型指针值指针}live()函数中 var stu *Student 类型 返回是 Prople指针 返回的内容 接口{ 类型指针 -&amp;gt; *Student 值指针 -&amp;gt; nil } if 接口类型 == nil 会判断类型指针 和 值指针 2个都为nil 结果才为T</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/archives/</guid>
      <description>archives</description>
    </item>
    
    <item>
      <title>搜索</title>
      <link>/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/search/</guid>
      <description>search</description>
    </item>
    
  </channel>
</rss>
