


[{"content":"下面这段代码输出什么，说明原因。\nfunc main() { slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { m[key] = \u0026amp;val } for k,v := range m { fmt.Println(k,\u0026#34;-\u0026gt;\u0026#34;,*v) } } 🔑 答案解析：\r注意此类问题在Go版本在1.22 版本后将会有变化 # 🔗:修复 Go 1.22 中的 For 循环\nGo \u0026gt;=1.22\n0 -\u0026gt; 0 1 -\u0026gt; 1 2 -\u0026gt; 2 3 -\u0026gt; 3 解释：Go \u0026lt;= 1.22 当 for key,val := range slice 时,每次循环都会创建新变量 key、val。从而实现每次循环的 key、val变量的地址都是不同的。\n在源代码上增加验证打印\npackage main import \u0026#34;fmt\u0026#34; func main() { slice := []int{0, 1, 2, 3} m := make(map[int]*int) for key, val := range slice { m[key] = \u0026amp;val fmt.Println(\u0026#34;key的值\u0026#34;, key, \u0026#34;key的地址\u0026#34;, \u0026amp;key, \u0026#34;slice[\u0026#34;, key, \u0026#34;] 的地址\u0026#34;, \u0026amp;slice[key], \u0026#34;val 的地址\u0026#34;, \u0026amp;val) } fmt.Println(\u0026#34;m集合的内容\u0026#34;, m) for k, v := range m { fmt.Println(k, \u0026#34;-\u0026gt;\u0026#34;, *v) } } //GO版本 1.22.4\rkey的值 0 key的地址 0xc00000a0e0 slice[ 0 ] 的地址 0xc000014200 val 的地址 0xc00000a0c8\rkey的值 1 key的地址 0xc00000a110 slice[ 1 ] 的地址 0xc000014208 val 的地址 0xc00000a0e8\rkey的值 2 key的地址 0xc00000a120 slice[ 2 ] 的地址 0xc000014210 val 的地址 0xc00000a118\rkey的值 3 key的地址 0xc00000a130 slice[ 3 ] 的地址 0xc000014218 val 的地址 0xc00000a128\rm集合的内容 map[0:0xc00000a0c8 1:0xc00000a0e8 2:0xc00000a118 3:0xc00000a128]\r0 -\u0026gt; 0\r1 -\u0026gt; 1\r2 -\u0026gt; 2\r3 -\u0026gt; 3 Go \u0026lt;1.22\n0 -\u0026gt; 3 1 -\u0026gt; 3 2 -\u0026gt; 3 3 -\u0026gt; 3 解析：当 for key,val := range slice 时，是创建了新变量 key、val。val变量的值 = 在每笔循环中都被赋值为slice元素的值。 当代码运行到m[key] = \u0026amp;val, m[key] 的值 = val变量的地址。共遍历了4轮，每轮都存储的是val变量的地址，又因为在每轮for中val的地址是不变的，但是val的地址指向的值在不断被赋值为slice元素的值 [0-\u0026gt;1-\u0026gt;2-\u0026gt;3]。因此for循环结束后m集合中值地址指向都为3\n在源代码上增加验证打印\npackage main import \u0026#34;fmt\u0026#34; func main() { slice := []int{0, 1, 2, 3} m := make(map[int]*int) for key, val := range slice { m[key] = \u0026amp;val fmt.Println(\u0026#34;key的值\u0026#34;, key, \u0026#34;key的地址\u0026#34;, \u0026amp;key, \u0026#34;slice[\u0026#34;, key, \u0026#34;] 的地址\u0026#34;, \u0026amp;slice[key], \u0026#34;val 的地址\u0026#34;, \u0026amp;val) } fmt.Println(\u0026#34;m集合的内容\u0026#34;, m) for k, v := range m { fmt.Println(k, \u0026#34;-\u0026gt;\u0026#34;, *v) } } //GO版本 1.20.5\rkey的值 0 key的地址 0xc00000a0c8 slice[ 0 ] 的地址 0xc00000e220 val 的地址 0xc00000a0e0\rkey的值 1 key的地址 0xc00000a0c8 slice[ 1 ] 的地址 0xc00000e228 val 的地址 0xc00000a0e0\rkey的值 2 key的地址 0xc00000a0c8 slice[ 2 ] 的地址 0xc00000e230 val 的地址 0xc00000a0e0\rkey的值 3 key的地址 0xc00000a0c8 slice[ 3 ] 的地址 0xc00000e238 val 的地址 0xc00000a0e0\rm集合的内容 map[0:0xc00000a0e0 1:0xc00000a0e0 2:0xc00000a0e0 3:0xc00000a0e0]\r0 -\u0026gt; 3\r1 -\u0026gt; 3\r2 -\u0026gt; 3\r3 -\u0026gt; 3 知识点: for range 循环的时候会创建每个元素的副本，而不是元素的引用\n参考资料：🔗:【golang】for range中取地址操作的陷阱\n","date":"1 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981/","section":"Go语言","summary":"","title":"Go每日一题（1）","type":"golang"},{"content":"本节用于记录GO相关的文章\n","date":"1 January 2022","externalUrl":null,"permalink":"/golang/","section":"Go语言","summary":"","title":"Go语言","type":"golang"},{"content":"欢迎来到我的网站！我很高兴你的来访。\n","date":"1 January 2022","externalUrl":null,"permalink":"/","section":"欢迎来到我的博客 ！","summary":"","title":"欢迎来到我的博客 ！","type":"page"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]