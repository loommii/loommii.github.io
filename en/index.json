


[{"content":"init() 函数是什么时候执行的？\n🔑 答案解析：\r答:init()是再main()函数执行前\n一句话总结： import –\u0026gt; const –\u0026gt; var –\u0026gt; init() –\u0026gt; main()\n如果有多个init就要分情况\n单个源文件的 init 执行顺序 结论： 同一个源文件的 init 函数执行顺序与其定义顺序一致，从上到下。\npackage main func init() { println(\u0026#34;init a\u0026#34;) } func init() { println(\u0026#34;init b\u0026#34;) } func init() { println(\u0026#34;init c\u0026#34;) } func main() { println(\u0026#34;main\u0026#34;) } $ go run main.go init a init b init c main 单个包的 init 执行顺序 结论： 同一个包中不同源文件 init 函数的执行顺序，是根据文件名的字典序来确定。\n// a.go package main func init() { println(\u0026#34;init a\u0026#34;) } // b.go package main func init() { println(\u0026#34;init b\u0026#34;) } // c.go package main func init() { println(\u0026#34;init c\u0026#34;) } // main.go package main func init() { println(\u0026#34;init main\u0026#34;) } func main() { println(\u0026#34;main\u0026#34;) } $ go build \u0026amp;\u0026amp; ./main init a init b init c init main main main 包导入多个包时 init 执行顺序-不存在依赖 结论： 对于不同的包，如果不相互依赖的话，按照 main 包中导入顺序调用包的 init 函数，最后再调用 main 包的 init 函数。\n// a 包 // a.go package a func init() { println(\u0026#34;init a\u0026#34;) } // b 包 // b.go package b func init() { println(\u0026#34;init b\u0026#34;) } // c 包 // c.go package c func init() { println(\u0026#34;init c\u0026#34;) } // main 包 // main.go package main import ( _ \u0026#34;main/a\u0026#34; _ \u0026#34;main/b\u0026#34; _ \u0026#34;main/c\u0026#34; ) func init() { println(\u0026#34;init main\u0026#34;) } func main() { println(\u0026#34;main\u0026#34;) } $ go build \u0026amp;\u0026amp; ./main init a init b init c init main main main 包导入多个包时 init 执行顺序-存在依赖 结论： 如果 package 存在依赖，不同包的 init 函数按照包导入的依赖关系决定执行顺序。 调用顺序为最后被依赖的最先被初始化，如导入顺序 main \u0026gt; a \u0026gt; b \u0026gt; c，则初始化顺序为 c \u0026gt; b \u0026gt; a \u0026gt; main，依次执行对应的 init 方法\n// a 包 // a.go package a import _ \u0026#34;main/b\u0026#34; func init() { println(\u0026#34;init a\u0026#34;) } // b 包 // b.go package b import _ \u0026#34;main/c\u0026#34; func init() { println(\u0026#34;init b\u0026#34;) } // c 包 // c.go package c func init() { println(\u0026#34;init c\u0026#34;) } // main 包 // main.go package main import ( _ \u0026#34;main/a\u0026#34; ) func init() { println(\u0026#34;init main\u0026#34;) } func main() { println(\u0026#34;main\u0026#34;) } $ go build \u0026amp;\u0026amp; ./main init c init b init a init main main 包级变量初始化与 init 函数执行顺序 结论:如果包存在包级变量，则先于包的 init 函数完成初始化。\n// a 包 // a.go package a import _ \u0026#34;main/b\u0026#34; var A = func() string { println(\u0026#34;init var A\u0026#34;) return \u0026#34;A\u0026#34; }() func init() { println(\u0026#34;init a\u0026#34;) } // b 包 // b.go package b import _ \u0026#34;main/c\u0026#34; var B = func() string { println(\u0026#34;init var B\u0026#34;) return \u0026#34;B\u0026#34; }() func init() { println(\u0026#34;init b\u0026#34;) } // c 包 // c.go package c var C = func() string { println(\u0026#34;init var C\u0026#34;) return \u0026#34;C\u0026#34; }() func init() { println(\u0026#34;init c\u0026#34;) } // main 包 // main.go package main import ( _ \u0026#34;main/a\u0026#34; ) var m = func() string { println(\u0026#34;init var m\u0026#34;) return \u0026#34;m\u0026#34; }() func init() { println(\u0026#34;init main\u0026#34;) } func main() { println(\u0026#34;main\u0026#34;) } $ go build \u0026amp;\u0026amp; ./main init var C init c init var B init b init var A init a init var m init main main 参考资料:\n🔗:一文读懂 Golang init 函数执行顺序 ","date":"10 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9810/","section":"Go语言","summary":"","title":"Go每日一题（10）","type":"golang"},{"content":"本节用于记录GO相关的文章\n","date":"10 January 2022","externalUrl":null,"permalink":"/golang/","section":"Go语言","summary":"","title":"Go语言","type":"golang"},{"content":"空 struct{} 占多少空间？有什么用途？\n🔑 答案解析：\r答:0 , 用于占位符\n例如:\nmap[string]struct{},只关注key是否存在的话可以使用节省内存空间 ch := make(chan struct{}, 1)，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。 type Lamp struct{} ,声明只包含方法的结构体。 type Lamp struct{} func (l Lamp) On() { println(\u0026#34;On\u0026#34;) } func (l Lamp) Off() { println(\u0026#34;Off\u0026#34;) } 解析: Go为每一种类型都有全局唯一的类型元数据，元数据记录了该类型大小。因为空结构体内没有任何的类型因此空类型的大小为0。但是因为有创建类型元数据因此可以想正常的类型一样用于占位 这里建议看一下参考资料【幼麟实验室】- Go类型系统讲解\n参考资料：\n🔗📺️:【幼麟实验室】- Go类型系统讲解 ","date":"9 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%989/","section":"Go语言","summary":"","title":"Go每日一题（9）","type":"golang"},{"content":"以下代码是否能编译通过？\n如何确认两个 map 是否相等？ 🔑 答案解析：\rmap 深度相等的条件：\n都为 nil 非空、长度相等，指向同一个 map 实体对象 相应的 key 指向的 value “深度”相等\n直接将使用 map1 == map2 是错误的。这种写法只能比较 map 是否为 nil。\npackage main import \u0026#34;fmt\u0026#34; func main() { var m map[string]int var n map[string]int fmt.Println(m == nil) fmt.Println(n == nil) // 不能通过编译 //fmt.Println(m == n) } 方案一: 遍历（比较麻烦） 遍历 map 的每个元素，比较元素是否都是深度相等。 方案二: 反射\npackage main import( \u0026#34;fmt\u0026#34; \u0026#34;relflect\u0026#34; ) func main() { var m map[string]int var n map[string]int fmt.Println(reflect.DeepEqual(m,n)) } 参考资料：\n🔗:reflect.DeepEqual函数：判断两个值是否一致 ","date":"8 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%988/","section":"Go语言","summary":"","title":"Go每日一题（8）","type":"golang"},{"content":"以下代码是否能编译通过？\npackage main import \u0026#34;fmt\u0026#34; func main() { m := make(map[string]int) fmt.Println(\u0026amp;m[\u0026#34;qcrao\u0026#34;]) } 🔑 答案解析：\r答:不能,编译报错\n.\\main.go:8:15: invalid operation: cannot take address of m[\u0026ldquo;qcrao\u0026rdquo;] (map index expression of type int)\n解析: 这个问题，相当于问：可以对 map 的元素直接取地址吗？\n知识点:无法直接对 map 的 key 或 value 进行取址。如果通过其他 hack 的方式，例如 unsafe.Pointer 等获取到了 key 或 value 的地址，也不能长期持有，因为一旦发生扩容，key 和 value 的位置就会改变，之前保存的地址也就失效了。\n","date":"7 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%987/","section":"Go语言","summary":"","title":"Go每日一题（7）","type":"golang"},{"content":"下面这段代码有什么缺陷：\nfunc sum(x, y int)(total int, error) { return x+y, nil } 🔑 答案解析：\r答案:(total int, error) 第二个返回值error没有命名\n解析: 在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。 func sum(x, y int)(total int,err error) {如果有多个返回值必须加上括号()； func sum(x, y int)(total int,err error) func sum(x, y int)int如果只有一个返回值且命名也必须加上括号()。func sum(x, y int)(total int) {\n这里的第一个返回值有命名 total，第二个没有命名，所以错误。\n","date":"6 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%986/","section":"Go语言","summary":"","title":"Go每日一题（6）","type":"golang"},{"content":"Go 的 map 可以边遍历边删除吗？\n🔑 答案解析：\r答：理论上可以。 https://go.dev/doc/effective_go#for ， 这个官方例子也展示了可以在遍历的时候删除。 https://go.dev/ref/spec#For_statements ， 同时官方的range迭代也有说着遍历时删除和新增的情况\n但是清注意 # map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。 并发的去读写map是十分危险的,建议直接用m=make(map[T]T)生成新的map对象,老的map让GC自动回收内存空间\n","date":"5 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%985/","section":"Go语言","summary":"","title":"Go每日一题（5）","type":"golang"},{"content":"下面两段代码输出什么。\n// 1. func main() { s := make([]int, 5) s = append(s, 1, 2, 3) fmt.Println(s) } // 2. func main() { s := make([]int,0) s = append(s,1,2,3,4) fmt.Println(s) } 🔑 答案解析：\r// 1\r[0 0 0 0 0 1 2 3]\r// 2\r[1 2 3 4] 解析: 首先了解一下切片的结构。\n// runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。\nmake([]int, 5) 等价于 make([]int, 5 , 5),会创建一个len = 5 cap = 5 的切片。s = append(s, 1, 2, 3) 会在切片长度(5)的后面增加1, 2, 3。\n底层数组[5] = 1\r底层数组[6] = 2\r底层数组[7] = 3 题目2 创建一个len = 0 cap = 0 的切片。\n参考资料：\n🔗:数组和切片有什么不同 🔗📺️:【Golang】slice类型存什么？make和new？slice和数组？扩容规则 🔗:制作分片、映射和信道 🔗:添加到和拷贝分片 ","date":"4 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984/","section":"Go语言","summary":"","title":"Go每日一题（4）","type":"golang"},{"content":"map 的 key 为什么是无序的？\n在遍历 map 的时候，我们会发现，输出的 key 是无序的。为什么？\n🔑 答案解析：\r在go \u0026lt;= 1.0 以后 迭代 map 的结果是无序的。 这是Golang map的实现原理导致的。在扩容中Map会指向新的桶，这是并不会立刻全部迁移，而是会指向新桶和旧桶。遍历Map上本质遍历这2个桶。但是发生了扩容Key的位置改变导致遍历的结果不同。 在go \u0026gt; 1.0 以前遍历Map的时候 不扩容时是有序的，扩容后将改变顺序。为了统一这个问题go\u0026gt;=1.0加入了遍历Map会随机播种，使得遍历无序。\n参考资料：\n🔗:key为什么是无序的 🔗:为什么遍历 Go map 是无序的(源码分析) ","date":"3 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983/","section":"Go语言","summary":"","title":"Go每日一题（3）","type":"golang"},{"content":"下面这段代码输出的内容\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(\u0026#34;打印前\u0026#34;) }() defer func() { fmt.Println(\u0026#34;打印中\u0026#34;) }() defer func() { fmt.Println(\u0026#34;打印后\u0026#34;) }() panic(\u0026#34;触发异常\u0026#34;) } 🔑 答案解析：\r打印后\r打印中\r打印前\rpanic: 触发异常 解析：defer 的执行顺序是后进先出。当出现 panic 语句的时候，会先按照 defer 的后进先出的顺序执行，最后才会执行panic。\n知识点:defer后进先出\n","date":"2 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982/","section":"Go语言","summary":"","title":"Go每日一题（2）","type":"golang"},{"content":"下面这段代码输出什么，说明原因。\nfunc main() { slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { m[key] = \u0026amp;val } for k,v := range m { fmt.Println(k,\u0026#34;-\u0026gt;\u0026#34;,*v) } } 🔑 答案解析：\r注意此类问题在Go版本在1.22 版本后将会有变化 # 🔗:修复 Go 1.22 中的 For 循环\nGo \u0026gt;=1.22\n0 -\u0026gt; 0 1 -\u0026gt; 1 2 -\u0026gt; 2 3 -\u0026gt; 3 解释：Go \u0026lt;= 1.22 当 for key,val := range slice 时,每次循环都会创建新变量 key、val。从而实现每次循环的 key、val变量的地址都是不同的。\n在源代码上增加验证打印\npackage main import \u0026#34;fmt\u0026#34; func main() { slice := []int{0, 1, 2, 3} m := make(map[int]*int) for key, val := range slice { m[key] = \u0026amp;val fmt.Println(\u0026#34;key的值\u0026#34;, key, \u0026#34;key的地址\u0026#34;, \u0026amp;key, \u0026#34;slice[\u0026#34;, key, \u0026#34;] 的地址\u0026#34;, \u0026amp;slice[key], \u0026#34;val 的地址\u0026#34;, \u0026amp;val) } fmt.Println(\u0026#34;m集合的内容\u0026#34;, m) for k, v := range m { fmt.Println(k, \u0026#34;-\u0026gt;\u0026#34;, *v) } } //GO版本 1.22.4\rkey的值 0 key的地址 0xc00000a0e0 slice[ 0 ] 的地址 0xc000014200 val 的地址 0xc00000a0c8\rkey的值 1 key的地址 0xc00000a110 slice[ 1 ] 的地址 0xc000014208 val 的地址 0xc00000a0e8\rkey的值 2 key的地址 0xc00000a120 slice[ 2 ] 的地址 0xc000014210 val 的地址 0xc00000a118\rkey的值 3 key的地址 0xc00000a130 slice[ 3 ] 的地址 0xc000014218 val 的地址 0xc00000a128\rm集合的内容 map[0:0xc00000a0c8 1:0xc00000a0e8 2:0xc00000a118 3:0xc00000a128]\r0 -\u0026gt; 0\r1 -\u0026gt; 1\r2 -\u0026gt; 2\r3 -\u0026gt; 3 Go \u0026lt;1.22\n0 -\u0026gt; 3 1 -\u0026gt; 3 2 -\u0026gt; 3 3 -\u0026gt; 3 解析：当 for key,val := range slice 时，是创建了新变量 key、val。val变量的值 = 在每笔循环中都被赋值为slice元素的值。 当代码运行到m[key] = \u0026amp;val, m[key] 的值 = val变量的地址。共遍历了4轮，每轮都存储的是val变量的地址，又因为在每轮for中val的地址是不变的，但是val的地址指向的值在不断被赋值为slice元素的值 [0-\u0026gt;1-\u0026gt;2-\u0026gt;3]。因此for循环结束后m集合中值地址指向都为3\n在源代码上增加验证打印\npackage main import \u0026#34;fmt\u0026#34; func main() { slice := []int{0, 1, 2, 3} m := make(map[int]*int) for key, val := range slice { m[key] = \u0026amp;val fmt.Println(\u0026#34;key的值\u0026#34;, key, \u0026#34;key的地址\u0026#34;, \u0026amp;key, \u0026#34;slice[\u0026#34;, key, \u0026#34;] 的地址\u0026#34;, \u0026amp;slice[key], \u0026#34;val 的地址\u0026#34;, \u0026amp;val) } fmt.Println(\u0026#34;m集合的内容\u0026#34;, m) for k, v := range m { fmt.Println(k, \u0026#34;-\u0026gt;\u0026#34;, *v) } } //GO版本 1.20.5\rkey的值 0 key的地址 0xc00000a0c8 slice[ 0 ] 的地址 0xc00000e220 val 的地址 0xc00000a0e0\rkey的值 1 key的地址 0xc00000a0c8 slice[ 1 ] 的地址 0xc00000e228 val 的地址 0xc00000a0e0\rkey的值 2 key的地址 0xc00000a0c8 slice[ 2 ] 的地址 0xc00000e230 val 的地址 0xc00000a0e0\rkey的值 3 key的地址 0xc00000a0c8 slice[ 3 ] 的地址 0xc00000e238 val 的地址 0xc00000a0e0\rm集合的内容 map[0:0xc00000a0e0 1:0xc00000a0e0 2:0xc00000a0e0 3:0xc00000a0e0]\r0 -\u0026gt; 3\r1 -\u0026gt; 3\r2 -\u0026gt; 3\r3 -\u0026gt; 3 知识点: for range 循环的时候会创建每个元素的副本，而不是元素的引用\n参考资料：\n🔗:【golang】for range中取地址操作的陷阱 ","date":"1 January 2022","externalUrl":null,"permalink":"/golang/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/go%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981/","section":"Go语言","summary":"","title":"Go每日一题（1）","type":"golang"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/en/","section":"loommii","summary":"","title":"loommii","type":"page"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]